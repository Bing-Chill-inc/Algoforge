<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: PartieEditeur/DictionnaireDonnee.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: PartieEditeur/DictionnaireDonnee.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Classe représentant un dictionnaire de données.
 * @extends HTMLElement
 */
class DictionnaireDonnee extends HTMLElement {
	// ATTRIBUTS
	_mesInformations; // Liste&lt;Information> Liste de toutes les variables
	_dictionnaireDesConvertionTypes = {
		Char: "String",
		int: "double",
		"unsigned int": "int",
	};
	_estOuvert = false;

	_matchSignification = {};
	_matchType = {};

	VARIABLE_SUPPR = "*variable_supprimee*";

	// CONSTRUCTEUR
	/**
	 * Crée une instance de DictionnaireDonnee.
	 * @param {Array} listeVariable - Liste des variables initiales.
	 */
	constructor(listeVariable = []) {
		super();
		this._mesInformations = listeVariable;

		// Affichage
		let iconeDico = document.createElement("div");
		iconeDico.classList.add("img");
		this.appendChild(iconeDico);

		document.getElementById("dico_btn").addEventListener("click", () => {
			if (this._estOuvert) this.fermer();
			else this.ouvrir();
		});
	}

	// ENCAPSULATION

	// METHODES
	/**
	 * Ouvre le dictionnaire de données.
	 */
	ouvrir() {
		document.querySelector("bibliotheque-algorithmique").fermer();
		document.getElementById("dico_wrapper").style.zIndex = 200;
		document.getElementById("boutonDico").classList.add("elementIsOpen");

		document
			.querySelector("editeur-interface")
			._planActif.effectuerDictionnaireDesDonnee();
		if (this._estOuvert) return;
		// Supprimer tout le contenu
		this.innerHTML = "";

		this.classList.add("ouvert");

		this.genererDictionnaire();

		// Ajout de la flèche de fermeture
		let flecheFermeture = document.createElement("span");
		flecheFermeture.innerHTML = "x";
		flecheFermeture.classList.add("fermeture");
		flecheFermeture.addEventListener("click", (e) => {
			e.stopPropagation();
			this.fermer();
		});
		this.appendChild(flecheFermeture);
		this._estOuvert = true;

		// Ajout d'un bouton de raffraichissement
		let boutonRaffraichir = document.createElement("span");
		boutonRaffraichir.innerHTML = "⟳";
		boutonRaffraichir.classList.add("raffraichir");
		boutonRaffraichir.addEventListener("click", (e) => {
			e.stopPropagation();
			boutonRaffraichir.classList.add("rotation");
			setTimeout(() => {
				boutonRaffraichir.classList.remove("rotation");
				this.fermer();
				this.ouvrir();
			}, 200);
		});
		this.appendChild(boutonRaffraichir);
	}

	/**
	 * Ferme le dictionnaire de données.
	 */
	fermer() {
		document.getElementById("dico_wrapper").style.zIndex = -200;
		document.getElementById("biblio_btn").removeAttribute("disabled");
		document.getElementById("boutonDico").classList.remove("elementIsOpen");

		// Supprimer tout le contenu
		this.innerHTML = "";

		this.classList.remove("ouvert");

		// Affichage de l'icone
		let iconeDico = document.createElement("div");
		iconeDico.classList.add("img");
		this.appendChild(iconeDico);
		this._estOuvert = false;
	}

	/**
	 * Génère le contenu du dictionnaire de données.
	 */
	genererDictionnaire() {
		let table = document.createElement("table");
		table.id = "tableDictionnaireDonnee";
		this.appendChild(table);

		// Entête
		let thEntete = document.createElement("th");
		table.appendChild(thEntete);

		let tdNom = document.createElement("td");
		tdNom.textContent = "Nom";
		thEntete.appendChild(tdNom);

		let tdType = document.createElement("td");
		tdType.textContent = "Type";
		thEntete.appendChild(tdType);

		let tdSignification = document.createElement("td");
		tdSignification.textContent = "Signification";
		thEntete.appendChild(tdSignification);

		// Contenu
		for (let info of this._mesInformations) {
			let trContent = document.createElement("tr");
			table.appendChild(trContent);

			let tdNom = document.createElement("td");
			tdNom.textContent = info._nom;
			tdNom.setAttribute("contenteditable", "true");
			trContent.append(tdNom);
			tdNom.addEventListener("keydown", (event) => {
				// On vérifie si la touche appuyée est "Entrée" ou "Espace"
				if (event.key === "Enter" || event.key === " ") {
					// On l'empêche pour éviter le saut de ligne, qui casse le design
					event.preventDefault();
				}
				// Demander confirmation pour la suppression si il ne reste qu'un caractère
				if (event.key === "Backspace" &amp;&amp; tdNom.innerText.length == 1) {
					if (
						!confirm(
							"Voulez-vous vraiment supprimer cette variable?",
						)
					) {
						event.preventDefault();
					} else {
						if (verbose) console.log(info);
						document
							.querySelector("plan-travail")
							.renameInformation(info._nom, this.VARIABLE_SUPPR);
						this._mesInformations.splice(
							this._mesInformations.indexOf(info),
							1,
						);
						this.fermer();
						this.ouvrir();
					}
				}
			});

			tdNom.addEventListener("input", () => {
				document
					.querySelector("editeur-interface")
					._planActif.renameInformation(info._nom, tdNom.innerText);
				this._matchSignification[tdNom.innerText] =
					this._matchSignification[info._nom];
				this._matchSignification[info._nom] = undefined;
				this._matchType[tdNom.innerText] = this._matchType[info._nom];
				this._matchType[info._nom] = undefined;
				info._nom = tdNom.innerText;
				// this._mesInformations.forEach((element) => {
				// 	if (element._nom == info._nom) {
				// 		document
				// 			.querySelector("editeur-interface")
				// 			._planActif.renameInformation(element._nom, tdNom.innerText);
				// 		this._matchSignification[tdNom.innerText] = this._matchSignification[element._nom];
				// 		this._matchSignification[element._nom] = undefined;
				// 		element._nom = tdNom.innerText;
				// 	}
				// });
			});

			let tdType = document.createElement("td");
			let selectType = document.createElement("select");
			selectType.classList.add("selectType");
			tdType.appendChild(selectType);

			let auto = document.createElement("option");
			auto.value = "automatique";
			auto.textContent = "automatique";
			selectType.appendChild(auto);

			auto.addEventListener("click", () => {
				this._matchType[info._nom] = undefined;
				// selectType.value = info._type; // Pour recharger automatiquement le type
			});

			for (let type of Type.allTypes) {
				let option = document.createElement("option");
				option.value = type;
				option.textContent = type;
				selectType.appendChild(option);
				option.addEventListener("click", () => {
					this._matchType[info._nom] = type;
				});
			}

			if (this._matchType) {
				if (this._matchType[info._nom] != undefined) {
					selectType.value = this._matchType[info._nom];
				} else {
					selectType.value = info._type;
					if (info._type == undefined) {
						selectType.value = "automatique";
					}
				}
			}
			trContent.append(tdType);

			let tdSignification = document.createElement("td");
			if (this._matchSignification) {
				tdSignification.textContent =
					this._matchSignification[info._nom];
			}
			tdSignification.setAttribute("contenteditable", "true");
			trContent.append(tdSignification);
			tdSignification.addEventListener("input", () => {
				this._matchSignification[info._nom] = tdSignification.innerText;
			});
		}
	}

	/**
	 * Ajoute une variable au dictionnaire.
	 * @param {Information} uneInformation - L'information à ajouter.
	 * @returns {boolean} - Retourne vrai si l'ajout a réussi, sinon faux.
	 */
	AjouterUneVariable(uneInformation) {
		if (uneInformation._nom == this.VARIABLE_SUPPR) {
			return false;
		}
		let reussis = false;
		const nameInformation = uneInformation._nom;
		if (uneInformation instanceof Information) {
			if (this.nomCorrecte(nameInformation)) {
				if (this.containInformation(nameInformation)) {
					const ancienType =
						this.getInformation(nameInformation)._type;
					const nouveauType = uneInformation._type;
					const resultType = this.convertionVariable(
						nouveauType,
						ancienType,
					);
					if (
						this.getInformation(nameInformation)._type != resultType
					) {
						this.changeType(uneInformation._nom, resultType);
					}
				} else {
					this._mesInformations.push(uneInformation);
					reussis = true;
				}
			}
		}
		return reussis;
	}

	/**
	 * Retire les informations absentes de la liste donnée.
	 * @param {Array} listeInformations - La liste des informations présentes.
	 */
	retirerInformationsAbsentes(listeInformations) {
		for (let info of this._mesInformations) {
			if (!listeInformations.includes(info)) {
				this.retirerUneInformation(info._nom);
			}
		}
	}

	/**
	 * Retire une information du dictionnaire.
	 * @param {string} nameVariable - Le nom de la variable à retirer.
	 * @returns {boolean} - Retourne vrai si la suppression a réussi.
	 */
	retirerUneInformation(nameVariable) {
		this._mesInformations = this._mesInformations.filter(
			(element) => element._nom != nameVariable,
		);
		return true;
	}

	/**
	 * Vérifie si deux types sont compatibles.
	 * @param {string} type1 - Le premier type.
	 * @param {string} type2 - Le deuxième type.
	 * @returns {boolean} - Retourne vrai si les types sont compatibles.
	 */
	TypeCompatible(type1, type2) {
		if (type1 == undefined || type2 == undefined) {
			return true;
		}
		let courant = type1;
		while (true) {
			if (!courant) {
				break;
			}
			if (type2 == courant) {
				return true;
			}
			courant = this._dictionnaireDesConvertionTypes[courant];
		}

		courant = type2;
		while (true) {
			if (!courant) {
				break;
			}
			if (type1 == courant) {
				return true;
			}
			courant = this._dictionnaireDesConvertionTypes[courant];
		}

		return false;
	}

	/**
	 * Convertit une variable d'un type à un autre.
	 * @param {string} informationUne - Le premier type.
	 * @param {string} InformationDeux - Le deuxième type.
	 * @returns {string} - Le type résultant de la conversion.
	 */
	convertionVariable(informationUne, InformationDeux) {
		// undefined
		// String
		// Char
		// unsigned double
		// double
		// boolean
		const type1 = informationUne;
		const type2 = InformationDeux;

		//Si Undefined
		if (type1 == undefined) {
			return type2;
		}
		if (type2 == undefined) {
			return type1;
		}

		// Si les deux types sont identiques non nécéssaire
		if (type1 === type2) {
			return type1;
		}

		// Si aucun des deux cas alors type1 est renvoyer
		return this.getTypeLePlusBasEnCommun(type1, type2);
	}

	/**
	 * Obtient le type le plus bas en commun entre deux types.
	 * @param {string} type1 - Le premier type.
	 * @param {string} type2 - Le deuxième type.
	 * @returns {string} - Le type le plus bas en commun.
	 */
	getTypeLePlusBasEnCommun(type1, type2) {
		let courant = type1;
		while (true) {
			if (!courant) {
				break;
			}
			if (type2 == courant) {
				return type2;
			}
			courant = this._dictionnaireDesConvertionTypes[courant];
		}
		courant = type2;
		while (true) {
			if (!courant) {
				break;
			}
			if (type1 == courant) {
				return type1;
			}
			courant = this._dictionnaireDesConvertionTypes[courant];
		}
		return type1;
	}

	/**
	 * Vérifie si le dictionnaire contient une information donnée.
	 * @param {string} nameInformation - Le nom de l'information.
	 * @returns {boolean} - Retourne vrai si l'information est présente.
	 */
	containInformation(nameInformation) {
		let trouver = false;
		this._mesInformations.forEach((element) => {
			if (element._nom == nameInformation) {
				trouver = true;
			}
		});
		return trouver;
	}

	/**
	 * Obtient une information par son nom.
	 * @param {string} nameInformation - Le nom de l'information.
	 * @returns {Information} - L'information trouvée.
	 */
	getInformation(nameInformation) {
		const foundElement = this._mesInformations.find(
			(element) => element._nom === nameInformation,
		);
		return foundElement;
	}

	/**
	 * Renomme une variable.
	 * @param {string} nameVariable - Le nom actuel de la variable.
	 * @param {string} newName - Le nouveau nom de la variable.
	 * @returns {boolean} - Retourne vrai si le renommage a réussi.
	 */
	renameInformation(nameVariable, newName) {
		let resultat = false;
		if (newName == "") {
			resultat = retirerUneInformation(nameVariable);
		} else if (!this.containInformation(newName)) {
			if (this.nomCorrecte(newName)) {
				this._mesInformations.forEach((element) => {
					if (element._nom == nameVariable) {
						element._nom = newName;
						resultat = true;
					}
				});
			}
		}
		return resultat;
	}

	/**
	 * Change la signification d'une variable.
	 * @param {string} nameVariable - Le nom de la variable.
	 * @param {string} nouvelleSignification - La nouvelle signification.
	 * @returns {boolean} - Retourne vrai si le changement a réussi.
	 */
	changeSignification(nameVariable, nouvelleSignification) {
		let resultat = false;
		this._mesInformations.forEach((element) => {
			if (element._nom == nameVariable) {
				element._signification = nouvelleSignification;
				resultat = true;
			}
		});
		return resultat;
	}

	/**
	 * Change le type d'une variable.
	 * @param {string} nameVariable - Le nom de la variable.
	 * @param {string} newType - Le nouveau type.
	 * @returns {boolean} - Retourne vrai si le changement a réussi.
	 */
	changeType(nameVariable, newType) {
		let resultat = false;
		this._mesInformations.forEach((element) => {
			if (element._nom == nameVariable) {
				element._type = newType;
				resultat = true;
			}
		});
		return resultat;
	}

	/**
	 * Vérifie si un nom de variable est correct.
	 * @param {string} nameVariable - Le nom de la variable.
	 * @returns {boolean} - Retourne vrai si le nom est correct.
	 */
	nomCorrecte(nameVariable) {
		let resultat = true;
		if (nameVariable.trim() == "") {
			resultat = false;
		}
		for (let char of nameVariable) {
			if (
				!(char >= "a" &amp;&amp; char &lt;= "z") &amp;&amp;
				!(char >= "A" &amp;&amp; char &lt;= "Z") &amp;&amp;
				char !== "_"
			) {
				resultat = false;
			}
		}
		return resultat;
	}

	/**
	 * Supprime les données inutilisées.
	 */
	suppressionDonneeInutiliser() {
		this._mesInformations = this._mesInformations.filter((element) => {
			return (
				element._type != undefined ||
				(element._signification != undefined &amp;&amp;
					element._signification != "")
			);
		});
	}

	/**
	 * Supprime toutes les informations du dictionnaire.
	 */
	suppressionTout() {
		this._mesInformations = [];
	}

	/**
	 * Convertit le dictionnaire en JSON.
	 * @returns {Object} - L'objet JSON représentant le dictionnaire.
	 */
	toJSON() {
		return {
			typeElement: "DictionnaireDonnee",
			types: this._matchType,
			signification: this._matchSignification,
		};
	}

	/**
	 * Exporte le dictionnaire dans un format donné.
	 * @param {string} format - Le format d'exportation (xls, csv, md).
	 */
	exporter(format) {
		switch (format.toLowerCase()) {
			case "xls":
				this.ouvrir();
				// Code snippet de la doc de SheetJS
				let aoa = [["Nom", "Type", "Signification"]];

				this._mesInformations.forEach((info) => {
					aoa.push([
						info._nom,
						`${
							this._matchType[info._nom]
								? this._matchType[info._nom]
								: info._type
						}`,
						this._matchSignification[info._nom]
							? this._matchSignification[info._nom]
							: "",
					]);
				});
				/* Create worksheet from Array of arrays */
				var ws = XLSX.utils.aoa_to_sheet(aoa);

				// Create a new workbook
				var wb = XLSX.utils.book_new();

				// Append the worksheet to the workbook
				XLSX.utils.book_append_sheet(wb, ws, "Dictionnaire"); // "Dictionnaire" is the worksheet name

				/* Export to file (start a download) */
				XLSX.writeFile(
					wb,
					`${
						document.querySelector("#titreAlgo").innerText
					}Dictionnaire.xls`,
				);
				this.fermer();
				break;
			case "csv":
				// On crée le contenu du fichier
				var contenuTexte = "Nom;Type;Signification\n";
				this.ouvrir();
				this.fermer();

				this._mesInformations.forEach((info) => {
					contenuTexte += `${info._nom};${info._type};${
						this._matchSignification[info._nom]
							? this._matchSignification[info._nom]
							: ""
					}\n`;
				});

				// On crée un Blob avec le contenu JSON
				var blob = new Blob([contenuTexte], {
					type: "application/json",
				});

				// On crée un URL pour le Blob
				var url = URL.createObjectURL(blob);

				// On crée un élément &lt;a> pour télécharger le fichier
				var downloadLink = document.createElement("a");
				downloadLink.href = url;
				downloadLink.download = `${
					document.querySelector("#titreAlgo").innerText
				}Dictionnaire.csv`;

				// Pour des raisons de compatibilité, on simule un clic sur le lien et on le supprime après
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);

				// On supprime le Blob et l'URL pour libérer de la mémoire
				setTimeout(() => URL.revokeObjectURL(url), 100);
				break;
			case "md":
				// On crée le contenu du fichier
				var contenuTexte = "Nom;Type;Signification\n";
				this.ouvrir();
				this.fermer();

				this._mesInformations.forEach((info) => {
					contenuTexte += `${info._nom};${info._type};${
						this._matchSignification[info._nom]
							? this._matchSignification[info._nom]
							: ""
					}\n`;
				});

				// On convertit le CSV en Markdown
				contenuTexte = this.csvToMarkdown(contenuTexte);

				// On crée un Blob avec le contenu Markdown
				var blob = new Blob([contenuTexte], {
					type: "text/markdown",
				});

				// On crée un URL pour le Blob
				var url = URL.createObjectURL(blob);

				// On crée un élément &lt;a> pour télécharger le fichier
				var downloadLink = document.createElement("a");
				downloadLink.href = url;
				downloadLink.download = `${
					document.querySelector("#titreAlgo").innerText
				}Dictionnaire.md`;

				// Pour des raisons de compatibilité, on simule un clic sur le lien et on le supprime après
				document.body.appendChild(downloadLink);
				downloadLink.click();
				document.body.removeChild(downloadLink);

				// On supprime le Blob et l'URL pour libérer de la mémoire
				setTimeout(() => URL.revokeObjectURL(url), 100);
				break;
			default:
				break;
		}
	}

	/**
	 * Charge le dictionnaire depuis un objet JSON.
	 * @param {Object} json - L'objet JSON contenant les données.
	 */
	chargerDepuisJSON(json) {
		this._matchType = json.types;
		this._matchSignification = json.signification;
	}

	/**
	 * Convertit une chaîne CSV en Markdown.
	 * @param {string} csvString - La chaîne CSV.
	 * @returns {string} - La chaîne Markdown.
	 */
	csvToMarkdown(csvString) {
		const rows = csvString.split("\n").filter((row) => row); // On sépare les lignes et ne gardons pas les lignes vides
		let markdown = "";

		rows.forEach((row, index) => {
			const columns = row.split(";"); // On découpe les lignes par le délimiteur
			// On entoure chaque colonne par des pipes pour les transformer en cellules de tableau
			const markdownRow = `| ${columns.join(" | ")} |`;

			markdown += markdownRow + "\n";

			// On ajoute une ligne de séparation après la première ligne pour créer l'entête
			if (index === 0) {
				const separator = columns.map(() => "---").join(" | ");
				markdown += `| ${separator} |\n`;
			}
		});

		return markdown;
	}
}
window.customElements.define("dictionnaire-donnee", DictionnaireDonnee);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnomalieConceptuelle.html">AnomalieConceptuelle</a></li><li><a href="AvertissementConceptuel.html">AvertissementConceptuel</a></li><li><a href="AvertissementDonneeDynamiquementTypee.html">AvertissementDonneeDynamiquementTypee</a></li><li><a href="AvertissementInformationsInconsistantesSi.html">AvertissementInformationsInconsistantesSi</a></li><li><a href="AvertissementPlanTropGrand.html">AvertissementPlanTropGrand</a></li><li><a href="AvertissementSProblemeJamaisExecute.html">AvertissementSProblemeJamaisExecute</a></li><li><a href="AvertissementStructureInoptimale.html">AvertissementStructureInoptimale</a></li><li><a href="AvertissementTropDeSousElements.html">AvertissementTropDeSousElements</a></li><li><a href="Bibliotheque.html">Bibliotheque</a></li><li><a href="Condition.html">Condition</a></li><li><a href="ConditionSortie.html">ConditionSortie</a></li><li><a href="DictionnaireDonnee.html">DictionnaireDonnee</a></li><li><a href="Editeur.html">Editeur</a></li><li><a href="ElementGraphique.html">ElementGraphique</a></li><li><a href="ElementMenu.html">ElementMenu</a></li><li><a href="ElementMenuCompose.html">ElementMenuCompose</a></li><li><a href="ElementMenuKeyboardTip.html">ElementMenuKeyboardTip</a></li><li><a href="ElementParent.html">ElementParent</a></li><li><a href="ErreurArretHorsIteratif.html">ErreurArretHorsIteratif</a></li><li><a href="ErreurArretIteratifBornee.html">ErreurArretIteratifBornee</a></li><li><a href="ErreurBoucleBorneeSansFin.html">ErreurBoucleBorneeSansFin</a></li><li><a href="ErreurBoucleSansSortie.html">ErreurBoucleSansSortie</a></li><li><a href="ErreurComparaisonSwitch.html">ErreurComparaisonSwitch</a></li><li><a href="ErreurConceptuelle.html">ErreurConceptuelle</a></li><li><a href="ErreurDonneeInutilisee.html">ErreurDonneeInutilisee</a></li><li><a href="ErreurDonneeMagique.html">ErreurDonneeMagique</a></li><li><a href="ErreurResultatInutilisee.html">ErreurResultatInutilisee</a></li><li><a href="ErreurSyntaxeAssignation.html">ErreurSyntaxeAssignation</a></li><li><a href="ErreurSyntaxeComparaison.html">ErreurSyntaxeComparaison</a></li><li><a href="ErreurTypesInconsistantsAlternatif.html">ErreurTypesInconsistantsAlternatif</a></li><li><a href="EvenementCreationElement.html">EvenementCreationElement</a></li><li><a href="EvenementDeplacementCondition.html">EvenementDeplacementCondition</a></li><li><a href="EvenementDeplacementElement.html">EvenementDeplacementElement</a></li><li><a href="EvenementDeplacementElementMultiples.html">EvenementDeplacementElementMultiples</a></li><li><a href="EvenementEdition.html">EvenementEdition</a></li><li><a href="EvenementEditionDonneesProbleme.html">EvenementEditionDonneesProbleme</a></li><li><a href="EvenementEditionExpressionSwitch.html">EvenementEditionExpressionSwitch</a></li><li><a href="EvenementEditionLibelleCondition.html">EvenementEditionLibelleCondition</a></li><li><a href="EvenementEditionLibelleProbleme.html">EvenementEditionLibelleProbleme</a></li><li><a href="EvenementEditionResultatsProbleme.html">EvenementEditionResultatsProbleme</a></li><li><a href="EvenementEditionStructureIterative.html">EvenementEditionStructureIterative</a></li><li><a href="EvenementEditionTexte.html">EvenementEditionTexte</a></li><li><a href="EvenementLiaison.html">EvenementLiaison</a></li><li><a href="EvenementSuppressionElement.html">EvenementSuppressionElement</a></li><li><a href="EvenementSuppressionLiaison.html">EvenementSuppressionLiaison</a></li><li><a href="FenetreModale.html">FenetreModale</a></li><li><a href="IndicateurZoom.html">IndicateurZoom</a></li><li><a href="Information.html">Information</a></li><li><a href="Initialise%252520l_indicateur%252520de%252520zoom%252520et%252520configure%252520les%252520boutons%252520de%252520zoom..html">Initialise l'indicateur de zoom et configure les boutons de zoom.</a></li><li><a href="Initialise%252520l_%2525C3%2525A9diteur%252520et%252520configure%252520les%252520%2525C3%2525A9v%2525C3%2525A9nements%252520et%252520les%252520%2525C3%2525A9l%2525C3%2525A9ments%252520de%252520l_interface%252520utilisateur..html">Initialise l'éditeur et configure les événements et les éléments de l'interface utilisateur.</a></li><li><a href="InviteBornesPourSI.html">InviteBornesPourSI</a></li><li><a href="InviteNouvelleBibliotheque.html">InviteNouvelleBibliotheque</a></li><li><a href="Lien.html">Lien</a></li><li><a href="LienCompositionProbleme.html">LienCompositionProbleme</a></li><li><a href="LienDroit.html">LienDroit</a></li><li><a href="LienTriple.html">LienTriple</a></li><li><a href="Ligne.html">Ligne</a></li><li><a href="MenuCompte.html">MenuCompte</a></li><li><a href="MenuContextuel.html">MenuContextuel</a></li><li><a href="MenuDeroulant.html">MenuDeroulant</a></li><li><a href="PlanTravail.html">PlanTravail</a></li><li><a href="Probleme.html">Probleme</a></li><li><a href="Procedure.html">Procedure</a></li><li><a href="RepresentationSelectionSimple.html">RepresentationSelectionSimple</a></li><li><a href="Selection.html">Selection</a></li><li><a href="SelectionRectangle.html">SelectionRectangle</a></li><li><a href="SousPlanTravail.html">SousPlanTravail</a></li><li><a href="StructureAlternative.html">StructureAlternative</a></li><li><a href="StructureIterative.html">StructureIterative</a></li><li><a href="StructureIterativeBornee.html">StructureIterativeBornee</a></li><li><a href="StructureIterativeNonBornee.html">StructureIterativeNonBornee</a></li><li><a href="StructureSi.html">StructureSi</a></li><li><a href="StructureSwitch.html">StructureSwitch</a></li><li><a href="SymboleDecomposition.html">SymboleDecomposition</a></li><li><a href="ThemeEditeur.html">ThemeEditeur</a></li><li><a href="Type.html">Type</a></li></ul><h3>Global</h3><ul><li><a href="global.html#sanitizeHTML">sanitizeHTML</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Feb 07 2025 10:30:36 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
