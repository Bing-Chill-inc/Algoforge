<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: PartieEditeur/Editeur.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: PartieEditeur/Editeur.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @class Editeur
 * @classdesc La classe Editeur est l'interface de notre éditeur, elle permet de créer des éléments graphiques et de les manipuler.&lt;br>
 * @description Est utilisé pour instancier l'Éditeur (il ne doit y en avoir qu'un).&lt;br>
 * @extends {HTMLElement}
 */
class Editeur extends HTMLElement {
	// ATTRIBUTS
	_logoAlgoForge = null;
	_themeSelect = null;
	_indicateurZoom = new IndicateurZoom();
	_currentTool = -1;
	_listeTools = [];
	_typesElements = [];
	_boutonPointeur = null;
	_undoButton = null;
	_redoButton = null;
	_pointePrecedementLien = null;
	_menuDeroulantFichier = null;
	_menuDeroulantEdition = null;
	_menuDeroulantAide = null;
	_espacePrincipal = null;
	_planActif = null;
	_selection = new Selection();
	_selectionRectangle = new SelectionRectangle();
	_coordonneesSelection = { x: 0, y: 0 };
	_isSelecting = false;
	_isDragging = false;
	_isMoving = false;
	_offsetX = 0;
	_offsetY = 0;
	_lastPosX = 0;
	_lastPosY = 0;
	_ancienPlusProche = null;
	MAX_CHAR_TITRE = 64;
	_barreOutilHorizontale = null;
	_clickSound = new Audio("Audio/Anvil_use.ogg");
	_clickSoundActivated = false;
	_boutonSauvegardeCloud = document.querySelector("#sauvegardeCloud");
	_pingSauvegardeCloud = document.querySelector("#pingSauvegardeCloud");
	_derniereVersionSauvegardee = null;
	_dernierTitreSauvegarde = "";

	_curMousePos = { x: 0, y: 0 };

	_toucheMeta;
	_toucheMetaAlt;

	_dictionnaireDesDonnees = new DictionnaireDonnee();
	_bibliotheque = new Bibliotheque();
	_modaleRaccourcisClavier;
	_modaleAPropos;
	_modaleNoPaste;
	_modaleNonImp;

	_pileAnnuler = []; // Pile pour les annulations de type Array&lt;EvenementEditeur>
	_pileRétablir = []; // Pile pour les rétablissements de type Array&lt;EvenementEditeur>

	_transferForm = document.getElementById("transferForm");
	_transferInput = document.getElementById("corpAlgo");
	_transferNomFichier = document.getElementById("nomFichier");
	_transferSourceImport = document.getElementById("sourceImport");

	/**
	 * @constructor
	 * Initialise l'éditeur et configure les événements et les éléments de l'interface utilisateur.
	 */
	constructor() {
		super();

		// Détection de la touche "Meta" (Cmd sur Mac, Ctrl sur Windows, Linux)
		if (
			window.navigator.userAgent.match(/(Mac|Windows|Linux)/)[0] === "Mac"
		) {
			this._toucheMeta = "⌘";
			this._toucheMetaAlt = "⌥";
		} else {
			this._toucheMeta = "Ctrl + ";
			this._toucheMetaAlt = "Alt + ";
		}

		fetch("modales/shortcuts.html").then((response) => {
			response.text().then((text) => {
				// Formater le texte pour remplacer les instances de '{metakey}' par la touche Meta
				text = text.replaceAll("{metakey}", this._toucheMeta);

				// remplacer les instances de '{altkey}' par la touche Alt
				text = text.replaceAll("{altkey}", this._toucheMetaAlt);
				this._modaleRaccourcisClavier = new FenetreModale(text);
				this.appendChild(this._modaleRaccourcisClavier);
			});
		});

		fetch("modales/about.html").then((response) => {
			response.text().then((text) => {
				this._modaleAPropos = new FenetreModale(text);
				this.appendChild(this._modaleAPropos);
			});
		});

		fetch("modales/nopaste.html").then((response) => {
			response.text().then((text) => {
				text = text.replaceAll("{metakey}", this._toucheMeta);
				this._modaleNoPaste = new FenetreModale(text);
				this.appendChild(this._modaleNoPaste);
			});
		});

		fetch("modales/notimplemented.html").then((response) => {
			response.text().then((text) => {
				this._modaleNonImp = new FenetreModale(text);
				this.appendChild(this._modaleNonImp);
			});
		});

		window.addEventListener("beforeunload", (e) => {
			if (
				(this._pileAnnuler.length > 0 ||
					this._pileRétablir.length > 0) &amp;&amp;
				!isElectron
			) {
				// Cancel the event
				e.preventDefault(); // If you prevent default behavior in Mozilla Firefox prompt will always be shown
				// Chrome requires returnValue to be set
				e.returnValue = "Attention";
				return "Attention";
			}
		});

		// Référencement des types d'éléments que l'on peut créer
		this._typesElements.push(Lien);
		this._typesElements.push(Probleme);
		this._typesElements.push(Procedure);
		this._typesElements.push(StructureSi);
		this._typesElements.push(StructureSwitch);
		this._typesElements.push(StructureIterativeNonBornee);
		this._typesElements.push(StructureIterativeBornee);
		this._typesElements.push(ConditionSortie);

		// Référencement des éléments d'interface
		this._espacePrincipal = document.querySelector("#espacePrincipal");
		this._espacePrincipal.appendChild(this._selection);
		this._espacePrincipal.appendChild(this._selectionRectangle);
		this._selectionRectangle.placer(-10, 0, -10, 0);
		this._planActif = this._espacePrincipal;

		this._logoAlgoForge = document.querySelector("#logoAlgoForge");
		this._themeSelect = document.querySelector("select#theme");
		document
			.getElementById("biblio_wrapper")
			.appendChild(this._bibliotheque);
		document
			.getElementById("dico_wrapper")
			.appendChild(this._dictionnaireDesDonnees);
		this._barreOutilHorizontale = document.querySelector("#actionsControl");
		this._barreOutilHorizontale.appendChild(this._indicateurZoom);

		this._boutonPointeur = document.querySelector("#boutonPointeur");

		this._listeTools.push(document.querySelector("#boutonLien"));
		this._listeTools.push(document.querySelector("#boutonProbleme"));
		this._listeTools.push(document.querySelector("#boutonProcedure"));
		this._listeTools.push(document.querySelector("#boutonStructureSi"));
		this._listeTools.push(document.querySelector("#boutonStructureSwitch"));
		this._listeTools.push(
			document.querySelector("#boutonStructureIterative"),
		);
		this._listeTools.push(
			document.querySelector("#boutonStructureIterativeBornee"),
		);
		this._listeTools.push(document.querySelector("#boutonConditionSortie"));

		this._undoButton = document.querySelector("#boutonUndo");
		this._redoButton = document.querySelector("#boutonRedo");

		this._menuDeroulantFichier = document.querySelector(
			"#menuDeroulantFichier",
		);
		this._menuDeroulantEdition = document.querySelector(
			"#menuDeroulantEdition",
		);
		this._menuDeroulantAide = document.querySelector("#menuDeroulantAide");

		this.querySelector("#titreAlgo").addEventListener("input", (event) => {
			// Update le titre de l'onglet
			document.title = "Algoforge - " + event.target.innerText;
		});

		setTimeout(() => {
			document.title =
				"Algoforge - " + this.querySelector("#titreAlgo").innerText;
		}, 1000);

		this.querySelector("#titreAlgo").addEventListener(
			"keydown",
			async (event) => {
				// On vérifie si la touche appuyée est "Entrée"
				if (event.key === "Enter") {
					// On l'empêche pour éviter le saut de ligne, qui casse le design
					event.preventDefault();

					// On enlève le focus de l'élément pour que le titre soit bien enregistré
					event.target.blur();

					// On sauvegarde l'algorithme
					if (isCloud()) await handdleSave();

					// Petite animation sur le crayon
					event.target.nextElementSibling.classList.add("rotate");
					event.target.nextElementSibling.classList.add(
						"move-right-2",
					);
					setTimeout(() => {
						event.target.nextElementSibling.classList.remove(
							"rotate",
						);
						event.target.nextElementSibling.classList.remove(
							"move-right-2",
						);
					}, 500);
				}

				if (verbose)
					console.log(
						`Le titre contient ${event.target.innerText.length} caractères sur ${this.MAX_CHAR_TITRE} autorisés.`,
					);
				// On vérifie si il y a trop de caractères
				if (
					event.target.innerText.length >= this.MAX_CHAR_TITRE &amp;&amp;
					event.key !== "Backspace" &amp;&amp;
					event.key !== "Delete"
				) {
					if (verbose) console.log("Trop de caractères");
					// On empêche l'ajout de caractères
					event.preventDefault();
				}
			},
		);

		this.querySelector("#titreAlgo").nextElementSibling.addEventListener(
			"click",
			(event) => {
				// On met le focus sur le titre
				event.target.previousElementSibling.focus();
			},
		);

		// Ajouter les options de thème
		this._themeSelect.appendChild(
			new ThemeEditeur(
				"Thème Pacifique", // nom
				"#F2F5F8", // bgColor
				"#E5EAF0", // bgColorSecondary
				"#BECBDA", // borderColor
				"#0C3245", // fgColor
				"#BECBDA55", // fgColorSemiTransparent
				"#BECBDA11", // fgColorTransparent
				"#33475C", // fgColorForward
				"#8ABE5E", // goodColor
				"#8ABE5E99", // goodColorTransparent
				"#D85959", // errorColor
				"#FFAD5A", // warningColor
				"#1C719C", // titleColor
				"Roboto, sans-serif", // fontFamily
				"", // glowColor
				"#bdc6c9", // borderColor2
				"#F2F5F870", // bgColorTertiary
				"#134D67", // fgColorHover
				"#7E7D73", // fgColorDisabled
				211, // baseGlowColor
			),
		);

		this._themeSelect.appendChild(
			new ThemeEditeur(
				"Thème AlgoForge", // nom
				"#161e27", // bgColor
				"#0f141a", // bgColorSecondary
				"#838787", // borderColor
				"#F2FBFF", // fgColor
				"#83878755", // fgColorSemiTransparent
				"#83878711", // fgColorTransparent
				"#A6AAA9", // fgColorForward
				"#D4E7C5", // goodColor
				"#D4E7C599", // goodColorTransparent
				"#FFA8A8", // errorColor
				"#FFD6AD", // warningColor
				"#34A5DA", // titleColor
				"Roboto, sans-serif", // fontFamily
				"", // glowColor
				"#1f2b38", // borderColor2
				"rgba(28,39,51,0.35)", // bgColorTertiary
				"#bdc6c9", // fgColorHover
				"rgba(166, 170, 169, .6)", // fgColorDisabled
				225, // baseGlowColor
			),
		);

		this._themeSelect.appendChild(
			new ThemeEditeur(
				"Thème FlashBang", // nom
				"#FFFFFF", // bgColor
				"#FFFFFF", // bgColorSecondary
				"#000000", // borderColor
				"#000000", // fgColor
				"#00000055", // fgColorSemiTransparent
				"#00000011", // fgColorTransparent
				"#000000", // fgColorForward
				"#00FF00", // goodColor
				"#00FF0099", // goodColorTransparent
				"#FF0000", // errorColor
				"#FFA300", // warningColor
				"#000000", // titleColor
				"Roboto, sans-serif", // fontFamily
				"", // glowColor
				"#000000", // borderColor2
				"#FFFFFF", // bgColorTertiary
				"#888888", // fgColorHover
				"#666666", // fgColorDisabled
				0, // baseGlowColor
			),
		);

		// Gestion des événements de thème
		this._themeSelect.addEventListener("change", () => {
			let theme =
				this._themeSelect.options[this._themeSelect.selectedIndex];
			theme.appliquer();
		});

		let theme = this.getCookie("theme");
		if (theme) {
			this._themeSelect.value = theme;
		} else {
			this._themeSelect.selectedIndex = 0;
		}
		try {
			this._themeSelect.options[
				this._themeSelect.selectedIndex
			].appliquer();
		} catch (error) {
			console.error("Le thème n'a pas pu être appliqué.");
			this._themeSelect.options[0].appliquer();
		}

		const isCloud = () => {
			const url = new URL(window.location.href);
			const hash = url.hash;
			return hash.startsWith("#/");
		};

		// Logo AlgoForge
		this._logoAlgoForge.addEventListener("click", () => {
			// Rediriger vers la page de connexion
			const cloudUrl = new URL(window.location.origin);
			cloudUrl.pathname = "/cloud/";
			window.open(cloudUrl.toString(), "_self");
		});

		const handdleSave = async () => {
			try {
				await saveAlgoToCloud();
				if (verbose) console.log("Algorithme sauvegardé avec succès !");
				this._derniereVersionSauvegardee =
					this._espacePrincipal.exporterEnJSON();
				this._dernierTitreSauvegarde =
					this.querySelector("#titreAlgo").innerText;
				this._pingSauvegardeCloud.style.display = "none";
			} catch (error) {
				console.error(
					"Erreur lors de la sauvegarde de l'algorithme :",
					error,
				);
				alert("Erreur lors de la sauvegarde de l'algorithme.");
			}
		};

		/**
		 * Charge l'algorithme à partir de l'URL.
		 * Fonctionne avec le cloud, il faut donc que l'utilisateur soit connecté.
		 * @returns {Promise&lt;void>}
		 */
		const loadAlgoFromURL = async () => {
			const url = new URL(window.location.href);
			const hash = url.hash;
			if (hash.startsWith("#/")) {
				const id = hash.substring(2);

				const API_BASE_URL = "/api/algos";
				const authToken = this.getCookie("authToken");
				if (!authToken) {
					window.location.href = "/cloud/";
					return;
				}
				const response = await fetch(`${API_BASE_URL}/${id}`, {
					method: "GET",
					headers: {
						Authorization: `Bearer ${authToken}`,
						"Content-Type": "application/json",
					},
				});

				const isresponseOk = response.ok;
				const responseData = await response.json();

				if (!isresponseOk)
					throw new Error(
						`Impossible de créer l'algorithme: ${responseData.message}`,
					);

				const sourceCode = JSON.stringify(responseData.data.sourceCode);

				this._espacePrincipal.chargerFichier(sourceCode);

				this.querySelector("#titreAlgo").innerText =
					responseData.data.nom;

				this._derniereVersionSauvegardee =
					this._espacePrincipal.exporterEnJSON();

				this._dernierTitreSauvegarde =
					this.querySelector("#titreAlgo").innerText;
			}
		};

		/**
		 * Sauvegarde l'algorithme dans le cloud.
		 * Fonctionne avec le cloud, il faut donc que l'utilisateur soit connecté.
		 * L'utilisateur doit aussi être sur un algorithme du cloud donc avec un hash.
		 * @returns {Promise&lt;void>}
		 */
		const saveAlgoToCloud = async () => {
			const url = new URL(window.location.href);
			const hash = url.hash;
			if (!hash.startsWith("#/")) return;

			const id = hash.substring(2);

			const newAlgo = {
				id: id,
				nom: this.querySelector("#titreAlgo").innerText,
				permsAlgorithme: [],
				sourceCode: this._espacePrincipal.exporterEnJSON(),
			};

			const API_BASE_URL = "/api/algos";
			const authToken = this.getCookie("authToken");
			if (!authToken) {
				console.error(
					"Vous devez être connecté pour accéder à cette page.",
				);
				return;
			}
			const response = await fetch(`${API_BASE_URL}/${id}`, {
				method: "PUT",
				headers: {
					Authorization: `Bearer ${authToken}`,
					"Content-Type": "application/json",
				},
				body: JSON.stringify(newAlgo),
			});

			const isresponseOk = response.ok;

			if (!isresponseOk)
				throw new Error(
					`Impossible de modifier l'algorithme: ${responseData.message}`,
				);
		};

		// Observer les modifications de l'algorithme
		const observer = new MutationObserver(() => {
			if (!isCloud()) return;
			const versionActuelle = this._espacePrincipal.exporterEnJSON();
			const titreActuel = this.querySelector("#titreAlgo").innerText;
			if (
				JSON.stringify(versionActuelle) !==
					JSON.stringify(this._derniereVersionSauvegardee) ||
				titreActuel !== this._dernierTitreSauvegarde
			) {
				this._pingSauvegardeCloud.style.display = "block";
			} else {
				this._pingSauvegardeCloud.style.display = "none";
			}
		});

		observer.observe(this._espacePrincipal, {
			childList: true,
			subtree: true,
			attributes: true,
			characterData: true,
		});

		// Détection du chargement de la page
		window.addEventListener("load", async () => {
			if (isCloud()) {
				this._boutonSauvegardeCloud.style.display = "flex";
				this._pingSauvegardeCloud.style.display = "block";

				// Bouton de sauvegarde
				this._boutonSauvegardeCloud.addEventListener(
					"click",
					async () => {
						await handdleSave();
					},
				);
			}
			await loadAlgoFromURL();
		});

		// Détection de la modification de l'URL
		window.addEventListener("popstate", async () => {
			location.reload();
		});

		// Ajout des éléments de menu
		// Fichier
		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu("Nouveau", () => {
				if (verbose) console.log("Nouveau");
				const url = new URL(window.location.href);
				const hash = url.hash;
				// On ouvre un nouvel onglet avec un éditeur vide
				if (hash.startsWith("#/")) {
					window.open(window.location.href.split("#")[0], "_blank");
					return;
				}
				window.open(window.location.href, "_blank");
			}),
		);
		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu("Ouvrir", () => {
				if (verbose) console.log("Ouvrir");
				// On importe
				// On crée un input de type file pour que l'utilisateur puisse choisir un fichier
				var fileInput = document.createElement("input");
				fileInput.type = "file";
				fileInput.accept = ".json,.tbr,.xml";
				fileInput.style.display = "none";
				fileInput.addEventListener("change", () => {
					if (!fileInput.files || fileInput.files.length === 0) return;
					const selectedFile = fileInput.files[0];
					var reader = new FileReader();
					reader.onload = () => {
						try {
							let nomFichier = selectedFile.name;
							if (verbose) console.log(selectedFile.size);
							if (selectedFile.size > 5000000) {
								alert(
									"Le fichier est trop volumineux (maximum 5 MégaOctets).",
								);
								return;
							}
							const algoInterprete = this.interpreterFichierAlgorithme(
								selectedFile.name,
								reader.result,
							);
							let nomAlgo = this.retirerExtensionNomFichier(nomFichier);
							if (algoInterprete.nomAlgo) {
								nomAlgo = algoInterprete.nomAlgo;
							}

							const estPlanVide = !Array.from(
								this._espacePrincipal.children,
							).some((element) => element instanceof ElementGraphique);

							if (estPlanVide) {
								this._espacePrincipal.chargerDepuisJSON(
									algoInterprete.algo,
								);
								this.querySelector("#titreAlgo").innerText = nomAlgo;
								document.title = "Algoforge - " + nomAlgo;
								if (algoInterprete.estTabulaRasa) {
									requestAnimationFrame(() => {
										this.prettifyPlanActif({
											enregistrerEvenement: false,
										});
									});
								}
								return;
							}

							this._transferInput.value = JSON.stringify(
								algoInterprete.algo,
							);
							this._transferNomFichier.value = nomAlgo;
							this._transferSourceImport.value = algoInterprete.estTabulaRasa
								? "tbr"
								: "";
							this._transferForm.submit();
						} catch (error) {
							alert(
								"Le fichier n'a pas été chargé correctement.",
							);
							console.error(error);
						}
					};
					reader.readAsText(selectedFile);
				});
				fileInput.click();
			}),
		);
		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu("Créer une copie", () => {
				if (verbose) console.log("Créer une copie");
				// On post le contenu de l'éditeur actuel dans un nouvel onglet
				this._transferInput.value = JSON.stringify(
					this._espacePrincipal.exporterEnJSON(),
				);
				this._transferNomFichier.value =
					this.querySelector("#titreAlgo").innerText + " - copie";
				this._transferSourceImport.value = "";
				this._transferForm.submit();
			}),
		);
		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu(
				"Partager",
				() => {
					if (verbose) console.log("Partager");
					this._modaleNonImp.ouvrir();
				},
				false,
			),
		);
		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu("Renommer", () => {
				if (verbose) console.log("Renommer");
				let titre = this.querySelector("#titreAlgo");
				// On met le focus sur le titre
				titre.focus();

				// On referme le menu en persuadant le navigateur que l'utilisateur n'a plus la souris dessus
				this._menuDeroulantFichier.style.display = "none";
				setTimeout(() => {
					this._menuDeroulantFichier.style.display = "";
				}, 2);

				// Et on sélectionne tout le texte sans execCommand car il est déprécié
				let range = document.createRange();
				range.selectNodeContents(titre);
				let selection = window.getSelection();
				selection.removeAllRanges();

				selection.addRange(range);
			}),
		);
		let exporter = new ElementMenuCompose("Exporter", () => {
			if (verbose) console.log("Exporter");
		});
		this._menuDeroulantFichier.ajouterElementMenu(exporter);

		let sousTitreGénéral = document.createElement("h3");
		sousTitreGénéral.innerText = "Algorithme";
		exporter.ajouterElementMenu(sousTitreGénéral);

		exporter.ajouterElementMenu(
			new ElementMenu(".json", () => {
				if (verbose) console.log("Exporter en .json");
				this.exporterJSON(
					JSON.stringify(this._espacePrincipal.exporterEnJSON()),
				);
			}),
		);

		let sousTitreAlgorithme = document.createElement("h3");
		sousTitreAlgorithme.innerText = "Image";
		exporter.ajouterElementMenu(sousTitreAlgorithme);

		exporter.ajouterElementMenu(
			new ElementMenu(
				".png",
				() => {
					if (verbose) console.log("Exporter en .png");
					const plansTravail = this.querySelectorAll("plan-travail");
					const sousPlansTravail =
						this.querySelectorAll("sous-plan-travail");

					const allPlansTravail = Array.from(plansTravail).concat(
						Array.from(sousPlansTravail),
					);

					allPlansTravail.forEach((planTravail, index) => {
						setTimeout(() => {
							this.exporterPNG(planTravail);
						}, index * 1500);
					});
				},
				true,
			),
		);

		exporter.ajouterElementMenu(
			new ElementMenu(
				".jpg",
				() => {
					if (verbose) console.log("Exporter en .jpg");
					const plansTravail = this.querySelectorAll("plan-travail");
					const sousPlansTravail =
						this.querySelectorAll("sous-plan-travail");

					const allPlansTravail = Array.from(plansTravail).concat(
						Array.from(sousPlansTravail),
					);

					allPlansTravail.forEach((planTravail, index) => {
						setTimeout(() => {
							this.exporterJPG(planTravail);
						}, index * 1500);
					});
				},
				true,
			),
		);

		exporter.ajouterElementMenu(
			new ElementMenu(".svg", () => {
				if (verbose) console.log("Exporter en .svg");
				this.exporterSVG(this._planActif);
			}),
		);

		exporter.ajouterElementMenu(
			new ElementMenu(".pdf", () => {
				window.print();
			}),
		);

		let sousTitreDictionnaire = document.createElement("h3");
		sousTitreDictionnaire.innerText = "Dictionnaire";
		exporter.ajouterElementMenu(sousTitreDictionnaire);

		exporter.ajouterElementMenu(
			new ElementMenu(".csv", () => {
				if (verbose) console.log("Exporter en .csv");
				this._dictionnaireDesDonnees.exporter("csv");
			}),
		);

		exporter.ajouterElementMenu(
			new ElementMenu(".md", () => {
				if (verbose) console.log("Exporter en .md");
				this._dictionnaireDesDonnees.exporter("md");
			}),
		);

		this._menuDeroulantFichier.ajouterElementMenu(
			new ElementMenu(
				"Supprimer",
				() => {
					if (verbose) console.log("Supprimer");
					this._modaleNonImp.ouvrir();
				},
				false,
			),
		);

		// Edition
		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenu("Importer", () => {
				if (verbose) console.log("Importer");
				this.importerJSON();
			}),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenu("Prettify", () => {
				if (verbose) console.log("Prettify");
				this.prettifyPlanActif();
			}),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Annuler",
				() => {
					if (verbose) console.log("Annuler");
					this.undo();
				},
				`${this._toucheMeta}Z`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Rétablir",
				() => {
					if (verbose) console.log("Rétablir");
					this.redo();
				},
				`${this._toucheMeta}Y`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Couper",
				() => {
					if (verbose) console.log("Couper");
					this.cut();
				},
				`${this._toucheMeta}X`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Copier",
				() => {
					if (verbose) console.log("Copier");
					this.copy();
				},
				`${this._toucheMeta}C`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Coller",
				() => {
					if (verbose) console.log("Coller");
					this._modaleNoPaste.ouvrir();
				},
				`${this._toucheMeta}V`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Sélectionner tout",
				() => {
					if (verbose) console.log("Sélectionner tout");
					this.selectAll();
				},
				`${this._toucheMeta}A`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Supprimer",
				() => {
					if (verbose) console.log("Supprimer");
					this.delete();
				},
				`Suppr / ${this._toucheMeta}⌫`,
			),
		);

		this._menuDeroulantEdition.ajouterElementMenu(
			new ElementMenuKeyboardTip(
				"Rechercher",
				() => {
					if (verbose) console.log("Rechercher");
					// this.search();
					this._modaleNonImp.ouvrir();
				},
				`${this._toucheMeta}F`,
				false,
			),
		);

		// Aide
		this._menuDeroulantAide.ajouterElementMenu(
			new ElementMenu("Tutoriels", () => {
				if (verbose) console.log("Tutoriels");
				// Open a new tab with the tutorials (wiki.&lt;current_domain>)
				window.open(
					`https://bing-chill-inc.github.io/wikiforge`,
					"_blank",
				);
			}),
		);

		this._menuDeroulantAide.ajouterElementMenu(
			new ElementMenu("Raccourcis clavier", () => {
				if (verbose) console.log("Raccourcis clavier");
				this._modaleRaccourcisClavier.ouvrir();
			}),
		);

		this._menuDeroulantAide.ajouterElementMenu(
			new ElementMenu("À propos", () => {
				if (verbose) console.log("À propos");
				this._modaleAPropos.ouvrir();
			}),
		);

		// Gestion des événements de l'interface
		this._listeTools.forEach((tool, index) => {
			tool.addEventListener("click", () => {
				this.selectTool(index);
			});
		});

		this._undoButton.addEventListener("click", () => {
			this.undo();
		});

		this._redoButton.addEventListener("click", () => {
			this.redo();
		});

		this._boutonPointeur.addEventListener("click", () => {
			this.selectTool(-1);
		});

		// Gestion des raccourcis clavier
		document.body.addEventListener("keydown", async (e) => {
			console.log(e);
			if (
				((!document.activeElement.isContentEditable &amp;&amp;
					e.target.nodeName !== "INPUT" &amp;&amp;
					e.target.nodeName !== "TEXTAREA") ||
					e.ctrlKey ||
					e.metaKey) &amp;&amp;
				e.key === "Delete"
			) {
				// Suppr
				e.preventDefault();
				this.delete();
			}

			// Contrôle de la sélection avec les flèches
			// vérifier si le curseur de l'utilisateur est dans un champ de texte
			if (
				!document.activeElement.isContentEditable &amp;&amp;
				e.target.nodeName !== "INPUT" &amp;&amp;
				e.target.nodeName !== "TEXTAREA"
			) {
				switch (e.key) {
					case "ArrowUp":
						this._selection.moveAllSelectedElements(0, -1);
						e.preventDefault();
						break;
					case "ArrowDown":
						this._selection.moveAllSelectedElements(0, 1);
						e.preventDefault();
						break;
					case "ArrowLeft":
						this._selection.moveAllSelectedElements(-1, 0);
						e.preventDefault();
						break;
					case "ArrowRight":
						this._selection.moveAllSelectedElements(1, 0);
						e.preventDefault();
						break;
				}
			}

			if (e.altKey &amp;&amp; !e.shiftKey &amp;&amp; !e.ctrlKey) {
				console.log(e);
				switch (e.code) {
					case "KeyB":
						e.preventDefault();
						if (!this._bibliotheque._estOuvert) {
							this._bibliotheque.ouvrir();
						} else {
							this._bibliotheque.fermer();
						}
						break;
					case "KeyD":
						e.preventDefault();
						if (!this._dictionnaireDesDonnees._estOuvert) {
							this._dictionnaireDesDonnees.ouvrir();
						} else {
							this._dictionnaireDesDonnees.fermer();
						}
						break;
				}
			}

			if ((e.ctrlKey || e.metaKey) &amp;&amp; !e.shiftKey &amp;&amp; !e.altKey) {
				// Raccourcis clavier en Ctrl + ... pour les outils
				switch (e.key) {
					case "@":
					case "²":
						// Ctrl + @ / ²
						e.preventDefault();
						this.selectTool(-1);
						break;
					case "1":
					case "&amp;":
						// Ctrl + 1
						e.preventDefault();
						this.selectTool(0);
						break;
					case "2":
					case "é":
						// Ctrl + 2
						e.preventDefault();
						this.selectTool(1);
						break;
					case "3":
					case '"':
						// Ctrl + 3
						e.preventDefault();
						this.selectTool(2);
						break;
					case "4":
					case "'":
						// Ctrl + 4
						e.preventDefault();
						this.selectTool(3);
						break;
					case "5":
					case "(":
						// Ctrl + 5
						e.preventDefault();
						this.selectTool(4);
						break;
					case "6":
					case "§":
						// Ctrl + 6 / §
						e.preventDefault();
						this.selectTool(5);
						break;
					case "7":
					case "è":
						// Ctrl + 7
						e.preventDefault();
						this.selectTool(6);
						break;
					case "8":
					case "!":
						// Ctrl + 8
						e.preventDefault();
						this.selectTool(7);
						break;
					default:
						break;
				}

				// Raccourcis clavier en Ctrl + ... pour l'édition
				if (e.key.toLowerCase() === "z") {
					// Ctrl + Z
					e.preventDefault();
					this.undo();
				}
				if (e.key.toLowerCase() === "y") {
					// Ctrl + Y
					e.preventDefault();
					this.redo();
				}
				if (e.key.toLowerCase() === "x") {
					// Ctrl + X
					e.preventDefault();
					this.cut();
				}
				if (e.key.toLowerCase() === "s") {
					e.preventDefault();
					if (isCloud()) await handdleSave();
				}
				if (e.key.toLowerCase() === "c") {
					// Ctrl + C
					if (verbose)
						console.log(
							"Ctrl + C",
							window.getSelection().toString(),
						);
					if (window.getSelection().toString().length == 0) {
						e.preventDefault();
						this.copy();
					}
				}
				if (e.key.toLowerCase() === "a") {
					// Ctrl + A
					if (document.activeElement.isContentEditable) return;
					e.preventDefault();
					this.selectAll();
				}
				if (e.key === "Backspace" || e.key === "Delete") {
					// Suppr
					e.preventDefault();
					this.delete();
				}
				if (e.key.toLowerCase() === "f") {
					// Ctrl + F
					e.preventDefault();
					this.search();
				}

				// Gestion du zoom
				if (e.key === "+" || e.key === "=") {
					// Ctrl + +
					e.preventDefault();
					this._indicateurZoom.zoomIn();
				}
				if (e.key === "-") {
					// Ctrl + -
					e.preventDefault();
					this._indicateurZoom.zoomOut();
				}
			}
		});

		document.body.addEventListener("wheel", (e) => {
			if (e.ctrlKey || e.metaKey) {
				e.preventDefault();
				if (e.deltaY &lt; 0) {
					this._indicateurZoom.zoomIn(0.01, false);
				} else {
					this._indicateurZoom.zoomOut(0.01, false);
				}
			}
		});

		this.addEventListener("dragover", (event) => {
			event.stopPropagation();
			event.preventDefault();
		});

		this.addEventListener("drop", (event) => {
			event.stopPropagation();
			event.preventDefault();

			try {
				const data = event.dataTransfer.getData("application/json");
				if (verbose) console.log("Dropped:", data);

				var parsedData = JSON.parse(data);

				if (verbose)
					console.log(
						`parsedData: ${parsedData} et typeof parsedData: ${typeof parsedData}`,
					);

				this._curMousePos = {
					x:
						((event.clientX / window.innerWidth) * 100) /
						this._indicateurZoom._zoom,
					y:
						((event.clientY / window.innerWidth) * 100) /
						this._indicateurZoom._zoom,
				}; // En vw

				// Ajouter les coordonnées de la souris
				const offsetYPlanTravailVW = 6; // En vw
				const appliquerDecalage = (elem) => {
					if (verbose)
						console.log(
							`parseFloat(elem.abscisse) + this._curMousePos.x + "vw" = ${parseFloat(
								elem.abscisse,
							)} + ${this._curMousePos.x} + "vw"
                            = ${
								parseFloat(elem.abscisse) +
								this._curMousePos.x +
								"vw"
							}`,
						);
					if (verbose)
						console.log(
							`parseFloat(elem.ordonnee) + this._curMousePos.y + "vw" = ${parseFloat(
								elem.ordonnee,
							)} + ${this._curMousePos.y} + "vw"
                            = ${
								parseFloat(elem.ordonnee) +
								this._curMousePos.y +
								"vw"
							}`,
						);
					elem.abscisse =
						parseFloat(elem.abscisse) + this._curMousePos.x + "vw";
					elem.ordonnee =
						parseFloat(elem.ordonnee) +
						this._curMousePos.y -
						offsetYPlanTravailVW +
						"vw";
					if (elem.enfants) {
						elem.enfants.forEach((enfant) => {
							appliquerDecalage(enfant);
						});
					}

					if (
						elem.typeElement == "StructureSi" ||
						elem.typeElement == "StructureIterative"
					) {
						for (let condition of elem.conditions) {
							condition.enfants.forEach((enfant) => {
								appliquerDecalage(enfant);
							});
						}
					}
				};

				parsedData.forEach((elem) => {
					appliquerDecalage(elem);
				});

				this.chargerDepuisJSON(parsedData);
			} catch (error) {
				console.error("Le fichier n'a pas été chargé correctement.");
				console.error(error);
			}
		});

		this.addEventListener("paste", (e) => {
			e.stopPropagation();
			if (verbose) console.log(e);
			if (verbose) console.log(e.clipboardData.getData("text/plain"));
			try {
				var parsedData = JSON.parse(
					e.clipboardData.getData("text/plain"),
				);

				// Ajouter les coordonnées de la souris
				const offsetYPlanTravailVW = 6; // En vw
				const appliquerDecalage = (elem) => {
					if (verbose)
						console.log(
							`parseFloat(elem.abscisse) + this._curMousePos.x + "vw" = ${parseFloat(
								elem.abscisse,
							)} + ${this._curMousePos.x} + "vw"
                            = ${
								parseFloat(elem.abscisse) +
								this._curMousePos.x +
								"vw"
							}`,
						);
					if (verbose)
						console.log(
							`parseFloat(elem.ordonnee) + this._curMousePos.y + "vw" = ${parseFloat(
								elem.ordonnee,
							)} + ${this._curMousePos.y} + "vw"
                            = ${
								parseFloat(elem.ordonnee) +
								this._curMousePos.y +
								"vw"
							}`,
						);
					elem.abscisse =
						parseFloat(elem.abscisse) + this._curMousePos.x + "vw";
					elem.ordonnee =
						parseFloat(elem.ordonnee) +
						this._curMousePos.y -
						offsetYPlanTravailVW +
						"vw";
					if (elem.enfants) {
						elem.enfants.forEach((enfant) => {
							appliquerDecalage(enfant);
						});
					}

					if (
						elem.typeElement == "StructureSi" ||
						elem.typeElement == "StructureIterative"
					) {
						for (let condition of elem.conditions) {
							condition.enfants.forEach((enfant) => {
								appliquerDecalage(enfant);
							});
						}
					}
				};

				parsedData.forEach((elem) => {
					appliquerDecalage(elem);
				});

				this.chargerDepuisJSON(parsedData);
			} catch (error) {
				console.error("Le fichier n'a pas été chargé correctement.");
				console.error(error);
			}
		});

		// Gestion des clics sur l'éditeur
		this.addEventListener("click", (e) => {
			e.stopPropagation();

			if (this._clickSoundActivated) {
				const clickSound = this._clickSound.cloneNode();
				clickSound.playbackRate = Math.random() * 0.2 + 0.9;
				clickSound.keep;
				clickSound.play();
			}

			// On supprime un éventuel menu contextuel
			let menuContextuel = document.querySelectorAll("menu-contextuel");
			for (let i = 0; i &lt; menuContextuel.length; i++) {
				menuContextuel[i].remove();
			}

			if (this._currentTool == null) {
				return;
			}
			if (verbose) console.log(e);
			// Remonter le DOM depuis e.target pour obtenir un élément utilisable
			let maTarget = e.target;
			// if (e.target.id === "espacePrincipal_wrapper") {
			// 	maTarget = document.getElementById("espacePrincipal");
			// } else { maTarget = e.target; }

			// Gestion des clics  sur des éléments qui ne doivent pas être ciblés
			if (e.target.classList.contains("nonCiblable")) {
				return;
			}
			while (
				!(maTarget instanceof ElementGraphique) &amp;&amp;
				!(maTarget instanceof PlanTravail) &amp;&amp;
				!(maTarget instanceof Condition) &amp;&amp;
				maTarget !== null
			) {
				maTarget = maTarget.parentElement;
				if (maTarget === null) {
					return;
				}
				// Gestion des clics  sur des éléments qui ne doivent pas être ciblés
				if (verbose) console.log(maTarget);
				if (verbose) console.log(maTarget.classList);
				if (verbose)
					console.log(maTarget.classList.contains("nonCiblable"));
				if (maTarget.classList.contains("nonCiblable")) {
					return;
				}
			}
			if (verbose) console.log(maTarget);
			if (maTarget instanceof PlanTravail) {
				if (verbose) console.log("Clic sur le plan de travail");
				if (verbose)
					console.log(
						"currentTool = " +
							this._currentTool +
							" et typesElements.length = " +
							this._typesElements.length,
					);
				if (
					this._currentTool !== null &amp;&amp;
					this._currentTool &lt; this._typesElements.length &amp;&amp;
					this._currentTool >= 0
				) {
					let element = this._typesElements[this._currentTool];
					if (verbose)
						console.log(
							"Création d'un élément de type " + element.name,
						);
					let elemPose = maTarget.ajouterElement(
						element,
						e.offsetX,
						e.offsetY,
						false,
					);
					if (elemPose instanceof StructureIterativeBornee) {
						elemPose.inviteBornes();
						this.querySelector(
							"invite-bornes-pour-si > input",
						).focus();
					}
				}
				if (this._currentTool === 0) {
					if (verbose)
						console.log(
							"Clic sur le plan de travail avec l'outil lien",
						);
					if (this._pointePrecedementLien !== null) {
						this._pointePrecedementLien.classList.remove(
							"pointePourLien",
						);
						this._pointePrecedementLien = null;
					}
				}
			} else if (
				maTarget instanceof ElementGraphique ||
				maTarget instanceof Condition
			) {
				if (verbose) console.log("Clic sur un élément graphique");
				if (this._currentTool === 0) {
					if (this._pointePrecedementLien === null) {
						if (verbose)
							console.log(
								"Premier clic sur un élément, on le pointe sil peut être décomposé",
							);
						if (maTarget.peutEtreDecompose()) {
							this._pointePrecedementLien = maTarget;
							maTarget.classList.add("pointePourLien");
							if (verbose)
								console.log(
									"On pointe l'élément " +
										this._pointePrecedementLien.constructor
											.name,
								);
						}
					} else {
						if (this._pointePrecedementLien == maTarget) {
							// Les éléments sont les mêmes, on ne fait rien
							this._pointePrecedementLien.classList.remove(
								"pointePourLien",
							);
							this._pointePrecedementLien = null;
							return;
						}

						if (
							this._pointePrecedementLien instanceof Condition &amp;&amp;
							maTarget instanceof Condition
						) {
							// On vérifie si les conditions ne sont pas dans la même structure
							if (
								this._pointePrecedementLien._structure ==
								maTarget._structure
							) {
								this._pointePrecedementLien.classList.remove(
									"pointePourLien",
								);
								this._pointePrecedementLien = maTarget;
								maTarget.classList.add("pointePourLien");
								return;
							}
						}

						// Les éléments sont différents, la connexion peut être faite
						// Si l'élément pointé précédemment est au dessus de l'élément pointé actuellement, il sera père de la relation
						if (verbose)
							console.log(
								`this._pointePrecedementLien._ordonnee=${this._pointePrecedementLien._ordonnee} et maTarget._ordonnee=${maTarget._ordonnee}`,
							);
						let parentRelation, enfantRelation;
						if (
							parseFloat(this._pointePrecedementLien._ordonnee) &lt;
							parseFloat(maTarget._ordonnee)
						) {
							parentRelation = this._pointePrecedementLien;
							enfantRelation = maTarget;
						} else {
							parentRelation = maTarget;
							enfantRelation = this._pointePrecedementLien;
						}

						// On crée la relation
						// Si le fils est une condition, le lien doit se faire avec sa structure
						if (enfantRelation instanceof Condition) {
							enfantRelation = enfantRelation._structure;
						}

						// On crée le lien
						parentRelation._elemParent.lierEnfant(enfantRelation);

						if (!e.shiftKey) {
							this._pointePrecedementLien.classList.remove(
								"pointePourLien",
							);
							this._pointePrecedementLien = null;
						}
					}
				}
			}
		});

		this.addEventListener("mousedown", function (e) {
			e.stopPropagation();
			let maTarget = e.target;

			// if (e.target.id === "espacePrincipal_wrapper") {
			// 	maTarget = document.getElementById("espacePrincipal");
			// } else { maTarget = e.target; }

			// Sur un click molette, on active le déplacement
			if (e.button === 1) {
				e.preventDefault();
				this._isMoving = true;
				_lastPosX = e.clientX;
				_lastPosY = e.clientY;
				return;
			}

			while (
				!(maTarget instanceof ElementGraphique) &amp;&amp;
				!(maTarget instanceof PlanTravail) &amp;&amp;
				!(maTarget instanceof Condition) &amp;&amp;
				maTarget !== null
			) {
				maTarget = maTarget.parentElement;
				if (maTarget === null) {
					return;
				}
				// Gestion des clics sur des éléments qui ne doivent pas être ciblés
				if (verbose) console.log(maTarget);
				if (verbose) console.log(maTarget.classList);
				if (verbose)
					console.log(maTarget.classList.contains("nonCiblable"));
				if (maTarget.classList.contains("nonCiblable")) {
					return;
				}
			}

			if (maTarget instanceof Condition) {
				maTarget = maTarget._structure;
			}

			if (!e.shiftKey &amp;&amp; !this._selection.estSelectionne(maTarget)) {
				if (verbose) console.log("Pas de shift, on désélectionne tout");
				this._selection.deselectionnerTout();
			}

			if (
				maTarget instanceof ElementGraphique &amp;&amp;
				!this._selection.estSelectionne(maTarget) &amp;&amp;
				this._currentTool != 0
			) {
				if (verbose) console.log("Sélection d'un élément graphique");
				this._selection.selectionnerElement(maTarget);
			} else if (e.shiftKey &amp;&amp; this._selection.estSelectionne(maTarget)) {
				this._selection.deselectionnerElement(maTarget);
			}

			if (verbose)
				console.log(`this._currentTool = ${this._currentTool}`);

			if (maTarget instanceof PlanTravail &amp;&amp; this._currentTool == -1) {
				if (verbose) console.log("event 1");
				this._isSelecting = true;
				this._coordonneesSelection.x =
					(this._curMousePos.x / 100) * window.innerWidth;
				this._coordonneesSelection.y =
					(this._curMousePos.y / 100) * window.innerWidth;
			} else {
				if (verbose) console.log("event 2");
				this._isDragging = true;
				this._lastPosX = e.clientX;
				this._lastPosY = e.clientY;
				this._evenementDeplacement =
					new EvenementDeplacementElementMultiples();
				for (let element of this._selection.getElementsSelectionnes()) {
					this._evenementDeplacement.ajouterElementDeplace(
						new EvenementDeplacementElement(element),
					);
				}
			}
		});
		this.addEventListener("mouseup", function (e) {
			e.stopPropagation();
			if (this._evenementDeplacement != null) {
				if (
					this._evenementDeplacement.estDecale() &amp;&amp;
					this._isDragging
				) {
					this.ajouterEvenement(this._evenementDeplacement);
				}
			}
			this._isDragging = false;
			this._isSelecting = false;
			this._isMoving = false;
			let listeElemsASelec =
				this._selectionRectangle.listerElementsGraphiques();
			for (let elem of listeElemsASelec) {
				this._selection.selectionnerElement(elem);
			}
			this._selectionRectangle.placer(-10, 0, -10, 0);
		});
		this.addEventListener("mousemove", function (e) {
			e.stopPropagation();
			if (this._isMoving) {
				if (
					e.clientX - this._lastPosX > 100 ||
					e.clientX - this._lastPosX &lt; -100
				) {
					this._lastPosX = e.clientX;
					this._lastPosY = e.clientY;
					return;
				}
				if (
					e.clientY - this._lastPosY > 100 ||
					e.clientY - this._lastPosY &lt; -100
				) {
					this._lastPosX = e.clientX;
					this._lastPosY = e.clientY;
					return;
				}
				this._planActif.scrollLeft -= e.clientX - this._lastPosX;
				this._planActif.scrollTop -= e.clientY - this._lastPosY;
				this._lastPosX = e.clientX;
				this._lastPosY = e.clientY;
				return;
			}
			this._curMousePos = {
				x:
					(((e.clientX + this._planActif.scrollLeft) /
						window.innerWidth) *
						100) /
					this._indicateurZoom._zoom,
				y:
					(((e.clientY + this._planActif.scrollTop) /
						window.innerWidth) *
						100) /
					this._indicateurZoom._zoom,
			}; // En vw
			if (verbose) console.info(`mousemove avec ${this._isDragging}`);
			if (verbose) console.info(this._curMousePos);
			if (this._isDragging) {
				let abscisseEnPx = e.clientX;
				let ordonneeEnPx = e.clientY;
				let decalageXEnPx = abscisseEnPx - this._lastPosX;
				let decalageYEnPx = ordonneeEnPx - this._lastPosY;
				let decalageXEnVw =
					((decalageXEnPx / window.innerWidth) * 100) /
					parseFloat(
						document.body.style.getPropertyValue("--sizeModifier"),
					);
				let decalageYEnVw =
					((decalageYEnPx / window.innerWidth) * 100) /
					parseFloat(
						document.body.style.getPropertyValue("--sizeModifier"),
					);
				this._selection.moveAllSelectedElements(
					decalageXEnVw,
					decalageYEnVw,
				);
				if (verbose)
					console.log(
						`Déplacement de la sélection de ${decalageXEnVw}vw en abscisse et de ${decalageYEnVw}vw en ordonnée`,
					);
				this._lastPosX = e.clientX;
				this._lastPosY = e.clientY;
			} else {
				// L'élément graphique dont le centre est le plus proche de la souris doit être devant les autres
				let distanceMin = 1000000;
				let elemLePlusProche = null;

				// Adapter les coordonnees de la souris pour les comparer avec les coordonnees des éléments graphiques
				// Convertir en vw
				let coordSouris = {
					x: (e.clientX / window.innerWidth) * 100,
					y: (e.clientY / window.innerWidth) * 100,
				};

				// Prendre en compte le zoom
				coordSouris.x /= parseFloat(
					document.body.style.getPropertyValue("--sizeModifier"),
				);
				coordSouris.y /= parseFloat(
					document.body.style.getPropertyValue("--sizeModifier"),
				);

				// Prendre en compte le scroll du plan de travail
				coordSouris.x +=
					(this._planActif.scrollLeft / window.innerWidth) * 100;
				coordSouris.y +=
					(this._planActif.scrollTop / window.innerWidth) * 100;

				// Trouver l'élément le plus proche
				for (let elem of this._planActif.trouverToutLesElementsGraphiques()) {
					let coordCentreElem = elem.getCentre();

					let distance = Math.sqrt(
						(coordSouris.x - coordCentreElem.x) ** 2 +
							(coordSouris.y - coordCentreElem.y) ** 2,
					);
					if (distance &lt; distanceMin) {
						distanceMin = distance;
						elemLePlusProche = elem;
					}
				}
				if (verbose) console.info(elemLePlusProche);
				if (
					elemLePlusProche != this._ancienPlusProche &amp;&amp;
					elemLePlusProche != null
				) {
					elemLePlusProche.parentNode.appendChild(elemLePlusProche);
					this._ancienPlusProche = elemLePlusProche;
				}
			}
			if (this._isSelecting) {
				let abscisseEnPx =
					(this._curMousePos.x / 100) * window.innerWidth -
					this._planActif.getBoundingClientRect().left /
						this._indicateurZoom._zoom;
				let ordonneeEnPx =
					(this._curMousePos.y / 100) * window.innerWidth -
					this._planActif.getBoundingClientRect().top /
						this._indicateurZoom._zoom;
				let abscisseEnVw = (abscisseEnPx / window.innerWidth) * 100;
				let ordonneeEnVw = (ordonneeEnPx / window.innerWidth) * 100;
				let lastXenVw =
					((this._coordonneesSelection.x -
						this._planActif.getBoundingClientRect().left /
							this._indicateurZoom._zoom) /
						window.innerWidth) *
					100;
				let lastYenVw =
					((this._coordonneesSelection.y -
						this._planActif.getBoundingClientRect().top /
							this._indicateurZoom._zoom) /
						window.innerWidth) *
					100;
				this._selectionRectangle.placer(
					abscisseEnVw,
					ordonneeEnVw,
					lastXenVw,
					lastYenVw,
				);
			}
		});

		this.addEventListener("contextmenu", function (e) {
			e.stopPropagation();
			e.preventDefault();

			// Calculer la position du menu contextuel
			let abscisse = e.clientX;
			let ordonnee = e.clientY;

			// Transformer les coordonnées en vw
			abscisse = (abscisse / window.innerWidth) * 100;
			ordonnee = (ordonnee / window.innerWidth) * 100;

			// Créer le menu contextuel
			this.appendChild(
				new MenuContextuel(
					abscisse,
					ordonnee,
					this._selection,
					e.target,
				),
			);
		});

		window.onbeforeprint = () => {
			// On met le zoom à 100% pour l'impression
			document.body.style.setProperty("--sizeModifier", 1.0);
		};

		window.onafterprint = () => {
			// On remet le zoom comme il était avant l'impression
			document.body.style.setProperty(
				"--sizeModifier",
				this._indicateurZoom._zoom,
			);
		};
	}

	/**
	 * Crée un cookie ou met à jour un cookie existant.
	 *
	 * @param {string} cname - Le nom du cookie.
	 * @param {string} cvalue - La valeur du cookie.
	 * @param {number} exdays - Le nombre de jours avant l'expiration du cookie.
	 */
	setCookie(cname, cvalue, exdays) {
		const d = new Date();
		d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
		let expires = "expires=" + d.toUTCString();
		document.cookie =
			cname + "=" + cvalue + ";" + expires + ";path=/;SameSite=Lax";
	}

	/**
	 * Récupère la valeur d'un cookie spécifié par son nom.
	 *
	 * @param {string} cname - Le nom du cookie à récupérer.
	 * @returns {string} La valeur du cookie si trouvé, sinon une chaîne vide.
	 */
	getCookie(cname) {
		let name = cname + "=";
		let decodedCookie = decodeURIComponent(document.cookie);
		let ca = decodedCookie.split(";");
		for (let i = 0; i &lt; ca.length; i++) {
			let c = ca[i];
			while (c.charAt(0) == " ") {
				c = c.substring(1);
			}
			if (c.indexOf(name) == 0) {
				return c.substring(name.length, c.length);
			}
		}
		return "";
	}

	/**
	 * Charge des éléments à partir d'un objet JSON et met à jour la sélection.
	 *
	 * @param {Object} json - L'objet JSON contenant les données des éléments à charger.
	 * @returns {void}
	 */
	chargerDepuisJSON(json) {
		this.ajouterEvenement(new EvenementPlaceholder()); // Marqueur de début d'événements
		const lesElements = this._planActif.chargerDepuisJSON(json);

		// On va aller chercher les événements qui viennent d'être créés et les aglomérer dans un événement composite
		const evenementComposite = new EvenementComposite();

		// On va parcourir this._pileAnnuler jusqu'à trouver le marqueur de début d'événements
		let index = this._pileAnnuler.length - 1;
		while (
			index >= 0 &amp;&amp;
			!(this._pileAnnuler[index] instanceof EvenementPlaceholder)
		) {
			evenementComposite.ajouterEvenement(this._pileAnnuler[index]);
			this._pileAnnuler.pop();
			index--;
		}

		// On retire aussi le marqueur de début d'événements
		this._pileAnnuler.pop();

		// evenementComposite.reverse();

		// On ajoute l'événement composite à la pile d'annulation
		this.ajouterEvenement(evenementComposite);

		// Désélectionner tout
		this._selection.deselectionnerTout();

		// Sélectionner les éléments et leurs enfants
		for (let elem of lesElements) {
			this._selection.selectionnerArbre(elem);
		}

		// On ouvre une invite pour les éléments de type StructureIterativeBornee s'il y en a un seul
		if (
			lesElements.length == 1 &amp;&amp;
			lesElements[0] instanceof StructureIterativeBornee
		) {
			lesElements[0].inviteBornes();
		}
	}

	/**
	 * Sélectionne un outil et met à jour le curseur en fonction de l'outil sélectionné.
	 *
	 * @param {number} idTool - L'identifiant de l'outil à sélectionner. Si idTool est -1, le pointeur est sélectionné.
	 *
	 * @description
	 * Cette méthode met à jour l'outil actuellement sélectionné et modifie le curseur du plan principal et des sous-plans de travail
	 * en fonction de l'outil sélectionné. Si un outil autre que le lien est sélectionné, elle enlève la classe "pointePourLien" de l'élément
	 * précédemment pointé.
	 *
	 * @example
	 * // Sélectionne l'outil avec l'identifiant 3 (Structure si)
	 * selectTool(3);
	 */
	selectTool(idTool) {
		this._currentTool = idTool;
		this._listeTools.forEach((tool) => {
			tool.classList.remove("selected");
			this._boutonPointeur.classList.remove("selected");
		});
		const planPrincipal = document.querySelector("plan-travail");
		const sousPlanTravail = document.querySelectorAll("sous-plan-travail");
		if (idTool != -1) {
			this._listeTools[idTool].classList.add("selected");
			const cursor =
				this._listeTools[idTool].src.split(".svg")[0] + "Cursor.svg";
			const urlColor = this._listeTools[idTool].src.split(".svg")[1];
			let goodCursor;
			switch (idTool) {
				// Lien
				case 0:
					goodCursor = `url(${cursor + urlColor}) 20 6, auto`;
					break;
				//Probleme, Procedure
				case 1:
				case 2:
					goodCursor = `url(${cursor + urlColor}) 10 6, auto`;
					break;
				// Structure si, Structure switch
				case 3:
				case 4:
					goodCursor = `url(${cursor + urlColor}) 14 6, auto`;
					break;
				// Boucle itérative non bornée
				case 5:
					goodCursor = `url(${cursor + urlColor}) 16 6, auto`;
					break;
				// Boucle itérative bornée
				case 6:
					goodCursor = `url(${cursor + urlColor}) 13 6, auto`;
					break;
				// Condition de sortie
				case 7:
					goodCursor = `url(${cursor + urlColor}) 22 6, auto`;
					break;
				default:
					goodCursor = `url(${cursor + urlColor}), auto`;
					break;
			}
			planPrincipal.style.cursor = goodCursor;
			sousPlanTravail.forEach((sousPlan) => {
				sousPlan.style.cursor = goodCursor;
			});
		} else {
			// Pointeur
			this._boutonPointeur.classList.add("selected");
			planPrincipal.style.cursor = `url(${this._boutonPointeur.src}), auto`;
			sousPlanTravail.forEach((sousPlan) => {
				sousPlan.style.cursor = `url(${this._boutonPointeur.src}), auto`;
			});
		}

		if (idTool != 0 &amp;&amp; this._pointePrecedementLien != null) {
			// Tout autre outil que le lien, on enlève la pointe de l'élément précédemment pointé
			this._pointePrecedementLien.classList.remove("pointePourLien");
			this._pointePrecedementLien = null;
		}
	}

	// Outils d'édition
	/**
	 * Annule la dernière action effectuée.
	 * Appelle la méthode `annuler` pour effectuer l'annulation.
	 */
	undo() {
		this.annuler();
	}

	/**
	 * Refaire l'action précédente annulée.
	 * Appelle la méthode `retablir` pour rétablir l'état précédent.
	 */
	redo() {
		this.retablir();
	}

	/**
	 * Coupe la sélection actuelle.
	 * Si le mode verbose est activé, affiche "cut" dans la console.
	 * Copie la sélection actuelle dans le presse-papiers et la supprime ensuite.
	 */
	cut() {
		if (verbose) console.log("cut");
		this.copy();
		this.delete();
	}

	/**
	 * Copie les éléments sélectionnés dans le presse-papiers ou retourne leur représentation JSON.
	 *
	 * @param {boolean} [toClipboard=true] - Indique si les éléments doivent être copiés dans le presse-papiers.
	 * @returns {string} La représentation JSON des éléments copiés.
	 */
	copy(toClipboard = true) {
		if (verbose) console.log("copy");
		let elementsACopier = [];
		let elementsSelectionnees = this._selection.getElementsSelectionnes(); // Liste des éléments sélectionnés
		for (let elementGraphique of elementsSelectionnees) {
			if (verbose) console.log(elementGraphique._parent);
			if (verbose &amp;&amp; elementGraphique._parent)
				console.log(
					elementsSelectionnees.indexOf(
						elementGraphique._parent._proprietaire,
					),
				);
			if (
				elementGraphique._parent == null ||
				elementsSelectionnees.indexOf(
					elementGraphique._parent._proprietaire,
				) == -1
			) {
				if (verbose) console.log(elementGraphique);
				elementsACopier.push(
					elementGraphique.toJSONspecifier(elementsSelectionnees),
				);
			}
		}

		if (toClipboard) {
			// Trouver le coin supérieur gauche de la sélection
			let coinSupGauche = this._selection.coin("center");
			if (verbose) console.log(coinSupGauche);

			// On convertit le coin supérieur gauche en vw
			coinSupGauche.x = (coinSupGauche.x / window.innerWidth) * 100;
			coinSupGauche.y = (coinSupGauche.y / window.innerWidth) * 100;

			// Soustraire les coordonnées du coin supérieur gauche pour que les coordonnées soient relatives
			const appliquerDecalage = (elem) => {
				if (verbose)
					console.log(
						`parseFloat(elem.abscisse) - coinSupGauche.x + "vw" = ${parseFloat(
							elem.abscisse,
						)} - ${coinSupGauche.x} + "vw"
                        = ${
							parseFloat(elem.abscisse) - coinSupGauche.x + "vw"
						}`,
					);
				if (verbose)
					console.log(
						`parseFloat(elem.ordonnee) - coinSupGauche.y + "vw" = ${parseFloat(
							elem.ordonnee,
						)} - ${coinSupGauche.y} + "vw"
                        = ${
							parseFloat(elem.ordonnee) - coinSupGauche.y + "vw"
						}`,
					);
				elem.abscisse =
					parseFloat(elem.abscisse) - coinSupGauche.x + "vw";
				elem.ordonnee =
					parseFloat(elem.ordonnee) - coinSupGauche.y + "vw";
				if (elem.enfants) {
					elem.enfants.forEach((enfant) => {
						appliquerDecalage(enfant);
					});
				}

				if (
					elem.typeElement == "StructureSi" ||
					elem.typeElement == "StructureIterative"
				) {
					for (let condition of elem.conditions) {
						condition.enfants.forEach((enfant) => {
							appliquerDecalage(enfant);
						});
					}
				}
			};

			elementsACopier.forEach((elem) => {
				appliquerDecalage(elem);
			});
		}

		if (verbose) console.log(elementsACopier);
		if (toClipboard)
			navigator.clipboard.writeText(JSON.stringify(elementsACopier));
		return JSON.stringify(elementsACopier);
	}

	/**
	 * Colle les données du presse-papiers et applique un décalage basé sur la position actuelle de la souris.
	 *
	 * @function
	 * @name paste
	 * @memberof Editeur
	 * @throws {Error} Lance une erreur si les données du presse-papiers ne sont pas au format JSON.
	 *
	 * @description
	 * Cette fonction lit les données du presse-papiers, les parse en JSON, puis applique un décalage aux coordonnées
	 * de chaque élément basé sur la position actuelle de la souris. Si les éléments contiennent des enfants ou des conditions,
	 * le décalage est également appliqué récursivement à ces sous-éléments. Enfin, les données modifiées sont chargées dans l'éditeur.
	 *
	 * @example
	 * // Exemple d'utilisation
	 * editeur.paste();
	 */
	paste() {
		if (verbose) console.log("paste");
		try {
			var parsedData = JSON.parse(readFromClipboard());

			// Ajouter les coordonnées de la souris
			const appliquerDecalage = (elem) => {
				if (verbose)
					console.log(
						`parseFloat(elem.abscisse) + this._curMousePos.x + "vw" = ${parseFloat(
							elem.abscisse,
						)} + ${this._curMousePos.x} + "vw"
                        = ${
							parseFloat(elem.abscisse) +
							this._curMousePos.x +
							"vw"
						}`,
					);
				if (verbose)
					console.log(
						`parseFloat(elem.ordonnee) + this._curMousePos.y + "vw" = ${parseFloat(
							elem.ordonnee,
						)} + ${this._curMousePos.y} + "vw"
                        = ${
							parseFloat(elem.ordonnee) +
							this._curMousePos.y +
							"vw"
						}`,
					);
				elem.abscisse =
					parseFloat(elem.abscisse) + this._curMousePos.x + "vw";
				elem.ordonnee =
					parseFloat(elem.ordonnee) + this._curMousePos.y + "vw";
				if (elem.enfants) {
					elem.enfants.forEach((enfant) => {
						appliquerDecalage(enfant);
					});
				}

				if (
					elem.typeElement == "StructureSi" ||
					elem.typeElement == "StructureIterative"
				) {
					for (let condition of elem.conditions) {
						condition.enfants.forEach((enfant) => {
							appliquerDecalage(enfant);
						});
					}
				}
			};

			parsedData.forEach((elem) => {
				appliquerDecalage(elem);
			});

			this.chargerDepuisJSON(parsedData);
		} catch (error) {
			console.error("Le fichier n'est pas au format JSON.");
		}
	}

	/**
	 * Sélectionne tous les éléments graphiques trouvés dans le plan actif.
	 * Utilise la méthode `trouverToutLesElementsGraphiques` pour récupérer les éléments graphiques,
	 * puis les sélectionne en utilisant la méthode `selectionnerElement` de l'objet `_selection`.
	 *
	 * @memberof Editeur
	 * @method selectAll
	 */
	selectAll() {
		if (verbose) console.log("selectAll");
		for (let elem of this._planActif.trouverToutLesElementsGraphiques()) {
			if (elem instanceof ElementGraphique)
				this._selection.selectionnerElement(elem);
		}
	}

	/**
	 * Supprime les éléments sélectionnés.
	 */
	delete() {
		if (verbose) console.log("delete");
		this._selection.supprimerTout();
	}

	/**
	 * Exporte le contenu de l'éditeur au format JSON.
	 *
	 * @param {string} jsonString - La chaîne JSON à exporter.
	 */
	exporterJSON(jsonString) {
		// On crée un Blob avec le contenu JSON
		var blob = new Blob([jsonString], { type: "application/json" });

		// On crée un URL pour le Blob
		var url = URL.createObjectURL(blob);

		// On crée un élément &lt;a> pour télécharger le fichier
		var downloadLink = document.createElement("a");
		downloadLink.href = url;
		downloadLink.download = `${
			this.querySelector("#titreAlgo").innerText
		}.json`;

		// Pour des raisons de compatibilité, on simule un clic sur le lien et on le supprime après
		document.body.appendChild(downloadLink);
		downloadLink.click();
		document.body.removeChild(downloadLink);

		// On supprime le Blob et l'URL pour libérer de la mémoire
		setTimeout(() => URL.revokeObjectURL(url), 100);
	}

	// Gestion des événements
	/**
	 * Ajoute un événement à la pile d'annulation.
	 *
	 * @param {Object} evenement - L'événement à ajouter.
	 */
	ajouterEvenement(evenement) {
		this._pileAnnuler.push(evenement);
		this._pileRétablir = [];
	}

	/**
	 * Annule le dernier événement.
	 */
	annuler() {
		if (this._pileAnnuler.length > 0) {
			let evenement = this._pileAnnuler.pop();
			evenement.annuler();
			this._pileRétablir.push(evenement);
		}
	}

	/**
	 * Rétablit le dernier événement annulé.
	 */
	retablir() {
		if (this._pileRétablir.length > 0) {
			let evenement = this._pileRétablir.pop();
			evenement.retablir();
			this._pileAnnuler.push(evenement);
		}
	}

	retirerExtensionNomFichier(nomFichier) {
		const dernierPoint = nomFichier.lastIndexOf(".");
		if (dernierPoint &lt;= 0) return nomFichier;
		return nomFichier.substring(0, dernierPoint);
	}

	nettoyerTexteImporte(texte) {
		if (typeof texte !== "string") return "";
		return texte.replace(/\r\n/g, "\n").trim();
	}

	nettoyerAssertionTbr(texte) {
		const texteNettoye = this.nettoyerTexteImporte(texte);
		return texteNettoye === "?" ? "" : texteNettoye;
	}

	estFichierTabulaRasa(nomFichier, contenu) {
		const nom = (nomFichier || "").toLowerCase();
		if (nom.endsWith(".tbr")) return true;
		if (typeof contenu !== "string") return false;

		const contenuTrim = contenu.trimStart();
		if (!contenuTrim.startsWith("&lt;")) return false;
		return (
			/&lt;\s*Algorithme[\s>]/i.test(contenu) &amp;&amp;
			/&lt;\s*Elements[\s>]/i.test(contenu)
		);
	}

	interpreterFichierAlgorithme(nomFichier, contenu) {
		if (this.estFichierTabulaRasa(nomFichier, contenu)) {
			return this.convertirTabulaRasaEnAlgoForge(contenu);
		}

		let parsedData = JSON.parse(contenu);
		if (typeof parsedData === "string") {
			parsedData = JSON.parse(parsedData);
		}
		return { algo: parsedData, nomAlgo: "", estTabulaRasa: false };
	}

	convertirPxTbrEnVw(positionPx) {
		const largeurReference = Math.max(window.innerWidth || 1, 1);
		return `${(positionPx / largeurReference) * 100}vw`;
	}

	extrairePositionTbr(noeud) {
		const brut = this.nettoyerTexteImporte(
			this.getTexteEnfantDirect(noeud, "Position", "0;0"),
		);
		const [xTexte = "0", yTexte = "0"] = brut.split(";");
		const x = parseFloat(xTexte.replace(",", "."));
		const y = parseFloat(yTexte.replace(",", "."));

		return {
			abscisse: this.convertirPxTbrEnVw(isNaN(x) ? 0 : x),
			ordonnee: this.convertirPxTbrEnVw(isNaN(y) ? 0 : y),
		};
	}

	trouverEnfantDirect(noeud, nomBalise) {
		if (!noeud) return null;
		for (const enfant of noeud.children) {
			if (enfant.tagName === nomBalise) return enfant;
		}
		return null;
	}

	getTexteEnfantDirect(noeud, nomBalise, valeurDefaut = "") {
		const enfant = this.trouverEnfantDirect(noeud, nomBalise);
		if (!enfant) return valeurDefaut;
		return enfant.textContent ?? valeurDefaut;
	}

	interpreterTitreIterationBornee(titreBrut) {
		const titre = this.nettoyerTexteImporte(titreBrut).replace(/\s+/g, " ");
		const valeurParDefaut = {
			variableAIterer: "i",
			borneInferieure: "BORNE_INF",
			borneSuperieure: "BORNE_SUP",
			pas: "1",
			croissant: true,
		};

		if (!titre) return valeurParDefaut;

		let correspondance = titre.match(
			/^pour\s+(.+?)\s+allant\s+de\s+(.+?)\s+[aà]\s+(.+)$/i,
		);
		if (!correspondance) {
			correspondance = titre.match(
				/^pour\s+(.+?)\s+de\s+(.+?)\s+[aà]\s+(.+)$/i,
			);
		}

		if (correspondance) {
			const variableAIterer = correspondance[1].trim();
			const borneInferieure = correspondance[2].trim();
			const borneSuperieure = correspondance[3].trim();
			const borneInfNum = parseFloat(borneInferieure);
			const borneSupNum = parseFloat(borneSuperieure);
			const croissant =
				isNaN(borneInfNum) || isNaN(borneSupNum)
					? true
					: borneSupNum >= borneInfNum;

			return {
				variableAIterer:
					variableAIterer || valeurParDefaut.variableAIterer,
				borneInferieure:
					borneInferieure || valeurParDefaut.borneInferieure,
				borneSuperieure:
					borneSuperieure || valeurParDefaut.borneSuperieure,
				pas: "1",
				croissant,
			};
		}

		const tailleCorrespondance = titre.match(
			/^pour\s+(.+?)\s+[aà]\s+la\s+taille\s+de\s+(.+)$/i,
		);
		if (tailleCorrespondance) {
			return {
				variableAIterer: tailleCorrespondance[1].trim() || "i",
				borneInferieure: "0",
				borneSuperieure: `taille(${tailleCorrespondance[2].trim()})`,
				pas: "1",
				croissant: true,
			};
		}

		const variableSeule = titre.match(/^pour\s+([^\s]+)/i);
		if (variableSeule) {
			valeurParDefaut.variableAIterer = variableSeule[1].trim() || "i";
		}

		return valeurParDefaut;
	}

	convertirOperationsTbr(noeud) {
		const operations = [];
		const operationsLogiques = this.trouverEnfantDirect(
			noeud,
			"operationsLogiques",
		);
		if (!operationsLogiques) return operations;

		for (const operation of operationsLogiques.children) {
			if (operation.tagName !== "operation") continue;
			operations.push({
				typeElement: "Condition",
				libelle: this.nettoyerTexteImporte(
					this.getTexteEnfantDirect(operation, "Titre", ""),
				),
				enfants: this.convertirEnfantsTbr(
					this.trouverEnfantDirect(operation, "Enfants"),
				),
			});
		}
		return operations;
	}

	convertirNoeudTbr(noeud) {
		const position = this.extrairePositionTbr(noeud);
		switch (noeud.tagName) {
			case "Action":
				return {
					typeElement: "Probleme",
					abscisse: position.abscisse,
					ordonnee: position.ordonnee,
					libelle: this.nettoyerTexteImporte(
						this.getTexteEnfantDirect(noeud, "Titre", ""),
					),
					listeDonnes: [
						this.nettoyerAssertionTbr(
							this.getTexteEnfantDirect(noeud, "PreAssertion", ""),
						),
					],
					listeResultats: [
						this.nettoyerAssertionTbr(
							this.getTexteEnfantDirect(noeud, "PostAssertion", ""),
						),
					],
					enfants: this.convertirEnfantsTbr(
						this.trouverEnfantDirect(noeud, "Enfants"),
					),
				};
			case "Condition":
				return {
					typeElement: "StructureSi",
					abscisse: position.abscisse,
					ordonnee: position.ordonnee,
					conditions: this.convertirOperationsTbr(noeud),
				};
			case "ConditionMultiple":
				return {
					typeElement: "StructureSwitch",
					abscisse: position.abscisse,
					ordonnee: position.ordonnee,
					expressionATester: this.nettoyerTexteImporte(
						this.getTexteEnfantDirect(noeud, "Titre", ""),
					),
					conditions: this.convertirOperationsTbr(noeud),
				};
			case "Iteration": {
				const iterationFixe =
					this.nettoyerTexteImporte(
						this.getTexteEnfantDirect(noeud, "IterationFixe", "0"),
					) === "1";
				const enfants = this.convertirEnfantsTbr(
					this.trouverEnfantDirect(noeud, "Enfants"),
				);

				if (!iterationFixe) {
					return {
						typeElement: "StructureIterativeNonBornee",
						abscisse: position.abscisse,
						ordonnee: position.ordonnee,
						enfants,
					};
				}

				const boucleBornee = this.interpreterTitreIterationBornee(
					this.getTexteEnfantDirect(noeud, "Titre", ""),
				);
				return {
					typeElement: "StructureIterativeBornee",
					abscisse: position.abscisse,
					ordonnee: position.ordonnee,
					variableAIterer: boucleBornee.variableAIterer,
					borneInferieure: boucleBornee.borneInferieure,
					borneSuperieure: boucleBornee.borneSuperieure,
					pas: boucleBornee.pas,
					croissant: boucleBornee.croissant,
					enfants,
				};
			}
			case "Sortie":
				return {
					typeElement: "ConditionSortie",
					abscisse: position.abscisse,
					ordonnee: position.ordonnee,
				};
			default:
				return null;
		}
	}

	convertirEnfantsTbr(noeudEnfants) {
		if (!noeudEnfants) return [];
		const enfants = [];
		for (const enfant of noeudEnfants.children) {
			const noeudConverti = this.convertirNoeudTbr(enfant);
			if (noeudConverti) enfants.push(noeudConverti);
		}
		return enfants;
	}

	obtenirEnfantsElementParentDansOrdre(elementParent) {
		if (!elementParent || !Array.isArray(elementParent._listeElementsEnfants)) {
			return [];
		}
		return elementParent._listeElementsEnfants
			.map((lien) => lien.element)
			.filter((element) => element instanceof ElementGraphique);
	}

	creerNoeudMiseEnPageDepuisElement(element) {
		const noeud = {
			typeElement: element.constructor.name,
			abscisse: element._abscisse,
			ordonnee: element._ordonnee,
			__elementReference: element,
		};
		if (element instanceof Probleme) {
			noeud.listeDonnes = Array.isArray(element.listeDonnes)
				? [...element.listeDonnes]
				: [];
			noeud.listeResultats = Array.isArray(element.listeResultats)
				? [...element.listeResultats]
				: [];
		}

		if (element instanceof StructureAlternative) {
			noeud.conditions = [];
			for (const condition of Array.from(element._listeConditions.children)) {
				noeud.conditions.push({
					__conditionElementReference: condition,
					enfants: this.creerForetMiseEnPageDepuisElements(
						this.obtenirEnfantsElementParentDansOrdre(
							condition._elemParent,
						),
					),
				});
			}
			return noeud;
		}

		if (element._elemParent) {
			noeud.enfants = this.creerForetMiseEnPageDepuisElements(
				this.obtenirEnfantsElementParentDansOrdre(element._elemParent),
			);
		}

		return noeud;
	}

	creerForetMiseEnPageDepuisElements(elements) {
		const foret = [];
		for (const element of elements) {
			foret.push(this.creerNoeudMiseEnPageDepuisElement(element));
		}
		return foret;
	}

	creerForetMiseEnPageDepuisPlan(planTravail) {
		if (!planTravail) return [];
		const racines = Array.from(planTravail.children).filter(
			(element) => element instanceof ElementGraphique &amp;&amp; element._parent == null,
		);
		return this.creerForetMiseEnPageDepuisElements(racines);
	}

	collecterDeplacementsNoeudMiseEnPage(noeud, deplacements) {
		if (noeud?.__elementReference instanceof ElementGraphique) {
			deplacements.push({
				element: noeud.__elementReference,
				anciennePos: [
					noeud.__elementReference._abscisse,
					noeud.__elementReference._ordonnee,
				],
				nouvellePos: [noeud.abscisse, noeud.ordonnee],
			});
		}

		if (Array.isArray(noeud?.enfants)) {
			this.collecterDeplacementsForetMiseEnPage(noeud.enfants, deplacements);
		}
		if (Array.isArray(noeud?.conditions)) {
			for (const condition of noeud.conditions) {
				if (Array.isArray(condition?.enfants)) {
					this.collecterDeplacementsForetMiseEnPage(
						condition.enfants,
						deplacements,
					);
				}
			}
		}
	}

	collecterDeplacementsForetMiseEnPage(foret, deplacements) {
		for (const noeud of foret) {
			this.collecterDeplacementsNoeudMiseEnPage(noeud, deplacements);
		}
	}

	prettifyPlanActif(options = {}) {
		const enregistrerEvenement = options.enregistrerEvenement ?? true;
		const foret = this.creerForetMiseEnPageDepuisPlan(this._planActif);
		if (foret.length === 0) return;

		this.reorganiserDispositionAlgoV2(foret);

		const deplacements = [];
		this.collecterDeplacementsForetMiseEnPage(foret, deplacements);

		const evenementPrettify = new EvenementDispositionAutomatique(deplacements);
		if (!evenementPrettify.estDecale()) return;

		evenementPrettify.retablir();
		if (enregistrerEvenement) {
			this.ajouterEvenement(evenementPrettify);
		}
	}

	obtenirHauteurReferenceNoeudMiseEnPage(typeElement) {
		switch (typeElement) {
			case "Probleme":
			case "Procedure":
				return 4.75;
			case "StructureSi":
			case "StructureSwitch":
				return 4;
			case "StructureIterativeBornee":
			case "StructureIterativeNonBornee":
				return 4;
			case "ConditionSortie":
				return 4;
			default:
				return 4;
		}
	}

	obtenirLargeurReferenceNoeudMiseEnPage(typeElement) {
		switch (typeElement) {
			case "Probleme":
			case "Procedure":
				return 30;
			case "StructureSi":
				return 12;
			case "StructureSwitch":
				return 14;
			case "StructureIterativeBornee":
				return 10;
			case "StructureIterativeNonBornee":
				return 8;
			case "ConditionSortie":
				return 6;
			default:
				return 12;
		}
	}

	obtenirLargeurElementEnVw(element) {
		if (!(element instanceof HTMLElement)) return 0;
		const rect = element.getBoundingClientRect();
		if (!rect || !isFinite(rect.width) || rect.width &lt;= 0) return 0;
		const largeurEnVwZoomee =
			(rect.width / Math.max(window.innerWidth || 1, 1)) * 100;
		const facteurZoom =
			parseFloat(document.body.style.getPropertyValue("--sizeModifier")) || 1;
		return largeurEnVwZoomee / Math.max(facteurZoom, 0.001);
	}

	obtenirHauteurElementEnVw(element) {
		if (!(element instanceof HTMLElement)) return 0;
		const rect = element.getBoundingClientRect();
		if (!rect || !isFinite(rect.height) || rect.height &lt;= 0) return 0;
		const hauteurEnVwZoomee =
			(rect.height / Math.max(window.innerWidth || 1, 1)) * 100;
		const facteurZoom =
			parseFloat(document.body.style.getPropertyValue("--sizeModifier")) || 1;
		return hauteurEnVwZoomee / Math.max(facteurZoom, 0.001);
	}

	obtenirLargeurEnteteConditionV2(condition, config) {
		const conditionReference = condition?.__conditionElementReference;
		const largeurMesuree = this.obtenirLargeurElementEnVw(conditionReference);
		if (largeurMesuree > 0) {
			return Math.max(
				config.largeurMinBrancheCondition,
				largeurMesuree * config.facteurLargeurEnteteCondition +
					config.margeEnteteCondition,
			);
		}
		return config.largeurMinBrancheCondition;
	}

	obtenirCoefficientLargeurProblemeV2(noeud) {
		const donnesVides = this.listeProblemeEstVide(noeud?.listeDonnes);
		const resultatsVides = this.listeProblemeEstVide(noeud?.listeResultats);
		if (donnesVides &amp;&amp; resultatsVides) return 0.5;
		if (donnesVides || resultatsVides) return 0.75;
		return 1;
	}

	obtenirDimensionsNoeudMiseEnPageV2(noeud, config) {
		const largeurReference = this.obtenirLargeurReferenceNoeudMiseEnPage(
			noeud.typeElement,
		);
		const hauteurReference = this.obtenirHauteurReferenceNoeudMiseEnPage(
			noeud.typeElement,
		);
		const elementReference = noeud?.__elementReference;
		const largeurMesuree = this.obtenirLargeurElementEnVw(elementReference);
		const hauteurMesuree = this.obtenirHauteurElementEnVw(elementReference);
		const largeurBase = largeurMesuree > 0 ? largeurMesuree : largeurReference;
		const hauteurBase = hauteurMesuree > 0 ? hauteurMesuree : hauteurReference;

		let facteurLargeur = config.facteurLargeurGeneral;
		if (noeud.typeElement === "ConditionSortie") {
			return {
				largeur: config.largeurConstanteSortie,
				hauteur: Math.max(config.hauteurMinNoeud, hauteurBase),
			};
		} else if (
			noeud.typeElement === "Probleme" ||
			noeud.typeElement === "Procedure"
		) {
			facteurLargeur =
				config.facteurLargeurProbleme *
				this.obtenirCoefficientLargeurProblemeV2(noeud);
		}

		const largeur = Math.max(
			config.largeurMinNoeud,
			largeurBase * facteurLargeur + config.margeNoeud,
		);
		const hauteur = Math.max(config.hauteurMinNoeud, hauteurBase);
		return { largeur, hauteur };
	}

	calculerMiseEnPageForetV2(foret, config) {
		if (!Array.isArray(foret) || foret.length === 0) return 0;
		let largeurForet = 0;
		for (let i = 0; i &lt; foret.length; i++) {
			const layoutNoeud = this.calculerMiseEnPageNoeudV2(foret[i], config);
			largeurForet += layoutNoeud.largeurSousArbre;
			if (i &lt; foret.length - 1) {
				largeurForet += config.ecartHorizontal;
			}
		}
		return largeurForet;
	}

	calculerMiseEnPageNoeudV2(noeud, config) {
		if (noeud?.__layoutV2) return noeud.__layoutV2;
		const dimensionsNoeud = this.obtenirDimensionsNoeudMiseEnPageV2(
			noeud,
			config,
		);

		if (
			noeud.typeElement === "StructureSi" ||
			noeud.typeElement === "StructureSwitch"
		) {
			const conditions = Array.isArray(noeud.conditions) ? noeud.conditions : [];
			let largeurConditions = 0;
			for (let i = 0; i &lt; conditions.length; i++) {
				const condition = conditions[i];
				condition.__largeurForetEnfantsV2 = this.calculerMiseEnPageForetV2(
					condition.enfants,
					config,
				);
				const largeurEnteteCondition =
					this.obtenirLargeurEnteteConditionV2(condition, config);
				condition.__largeurBrancheV2 = Math.max(
					config.largeurMinBrancheCondition,
					largeurEnteteCondition,
					condition.__largeurForetEnfantsV2,
				);
				largeurConditions += condition.__largeurBrancheV2;
				if (i &lt; conditions.length - 1) {
					largeurConditions += config.ecartHorizontalConditions;
				}
			}

			noeud.__layoutV2 = {
				type: "conditions",
				largeurNoeud: dimensionsNoeud.largeur,
				hauteurNoeud: dimensionsNoeud.hauteur,
				largeurSousArbre: Math.max(dimensionsNoeud.largeur, largeurConditions),
				largeurConditions,
			};
			return noeud.__layoutV2;
		}

		const largeurEnfants = this.calculerMiseEnPageForetV2(noeud.enfants, config);
		noeud.__layoutV2 = {
			type: "enfants",
			largeurNoeud: dimensionsNoeud.largeur,
			hauteurNoeud: dimensionsNoeud.hauteur,
			largeurSousArbre: Math.max(dimensionsNoeud.largeur, largeurEnfants),
			largeurEnfants,
		};
		return noeud.__layoutV2;
	}

	appliquerMiseEnPageForetV2(foret, gauche, haut, config) {
		if (!Array.isArray(foret) || foret.length === 0) return;
		let curseur = gauche;
		for (let i = 0; i &lt; foret.length; i++) {
			const noeud = foret[i];
			const layoutNoeud = this.calculerMiseEnPageNoeudV2(noeud, config);
			this.appliquerMiseEnPageNoeudV2(noeud, curseur, haut, config);
			curseur += layoutNoeud.largeurSousArbre + config.ecartHorizontal;
		}
	}

	appliquerMiseEnPageNoeudV2(noeud, gauche, haut, config) {
		const layoutNoeud = this.calculerMiseEnPageNoeudV2(noeud, config);
		const positionX =
			gauche + (layoutNoeud.largeurSousArbre - layoutNoeud.largeurNoeud) / 2;
		noeud.abscisse = `${positionX}vw`;
		noeud.ordonnee = `${haut}vw`;

		const hautSuivant = haut + config.ecartVertical;

		if (layoutNoeud.type === "enfants") {
			if (layoutNoeud.largeurEnfants &lt;= 0) return;
			const enfants = Array.isArray(noeud.enfants) ? noeud.enfants : [];
			if (enfants.length === 1) {
				const enfantUnique = enfants[0];
				const layoutEnfantUnique = this.calculerMiseEnPageNoeudV2(
					enfantUnique,
					config,
				);
				const gaucheEnfantUnique =
					gauche +
					(layoutNoeud.largeurSousArbre - layoutEnfantUnique.largeurSousArbre) /
						2;
				this.appliquerMiseEnPageNoeudV2(
					enfantUnique,
					gaucheEnfantUnique,
					hautSuivant,
					config,
				);
				return;
			}

			const gaucheEnfants =
				gauche + (layoutNoeud.largeurSousArbre - layoutNoeud.largeurEnfants) / 2;
			this.appliquerMiseEnPageForetV2(
				enfants,
				gaucheEnfants,
				hautSuivant,
				config,
			);
			return;
		}

		if (layoutNoeud.type === "conditions") {
			if (layoutNoeud.largeurConditions &lt;= 0) return;
			let curseurBranche =
				gauche +
				(layoutNoeud.largeurSousArbre - layoutNoeud.largeurConditions) / 2;
			const conditions = Array.isArray(noeud.conditions) ? noeud.conditions : [];

			for (const condition of conditions) {
				const largeurBranche = condition.__largeurBrancheV2 || 0;
				const largeurForetCondition = condition.__largeurForetEnfantsV2 || 0;
				condition.__centreBrancheV2 = curseurBranche + largeurBranche / 2;
				const enfantsCondition = Array.isArray(condition.enfants)
					? condition.enfants
					: [];

				if (largeurForetCondition > 0 &amp;&amp; enfantsCondition.length > 0) {
					if (enfantsCondition.length === 1) {
						const enfantUnique = enfantsCondition[0];
						const layoutEnfantUnique = this.calculerMiseEnPageNoeudV2(
							enfantUnique,
							config,
						);
						const gaucheEnfantUnique =
							curseurBranche +
							(largeurBranche - layoutEnfantUnique.largeurSousArbre) / 2;
						this.appliquerMiseEnPageNoeudV2(
							enfantUnique,
							gaucheEnfantUnique,
							hautSuivant,
							config,
						);
					} else {
						const gaucheForetCondition =
							curseurBranche + (largeurBranche - largeurForetCondition) / 2;
						this.appliquerMiseEnPageForetV2(
							enfantsCondition,
							gaucheForetCondition,
							hautSuivant,
							config,
						);
					}
				}

				curseurBranche += largeurBranche + config.ecartHorizontalConditions;
			}
		}
	}

	obtenirLargeurEmpreinteNoeudV2(noeud, config, bornesStrictes = false) {
		if (noeud?.typeElement === "ConditionSortie") {
			if (bornesStrictes) {
				return Math.max(
					config.largeurMinEmpreinteNoeud,
					config.largeurConstanteSortie,
				);
			}
			return Math.max(
				config.largeurMinEmpreinteNoeud,
				config.largeurEmpreinteSortieConstante,
			);
		}

		const largeurMesuree = this.obtenirLargeurElementEnVw(
			noeud?.__elementReference,
		);
		if (largeurMesuree > 0) {
			if (bornesStrictes) {
				return Math.max(config.largeurMinEmpreinteNoeud, largeurMesuree);
			}
			if (
				noeud?.typeElement === "Probleme" ||
				noeud?.typeElement === "Procedure"
			) {
				const coefficientProbleme =
					this.obtenirCoefficientLargeurProblemeV2(noeud);
				const facteurEmpreinteProbleme =
					coefficientProbleme &lt;= 0.5
						? config.facteurEmpreinteProblemeSansDR
						: coefficientProbleme &lt; 1
							? config.facteurEmpreinteProblemePartiel
							: config.facteurEmpreinteProbleme;
				return Math.max(
					config.largeurMinEmpreinteNoeud,
					largeurMesuree * facteurEmpreinteProbleme,
				);
			}
			return Math.max(
				config.largeurMinEmpreinteNoeud,
				largeurMesuree * config.facteurEmpreinteGeneral,
			);
		}

		const layoutNoeud = noeud?.__layoutV2;
		if (layoutNoeud?.largeurNoeud) {
			if (bornesStrictes) {
				return Math.max(
					config.largeurMinEmpreinteNoeud,
					layoutNoeud.largeurNoeud,
				);
			}
			return Math.max(
				config.largeurMinEmpreinteNoeud,
				layoutNoeud.largeurNoeud,
			);
		}
		return config.largeurMinEmpreinteNoeud;
	}

	calculerBornesNoeudV2(noeud, config, bornesStrictes = false) {
		if (!noeud) return { minX: Infinity, maxX: -Infinity };
		const layoutNoeud = this.calculerMiseEnPageNoeudV2(noeud, config);
		const gaucheNoeud = parseFloat(noeud.abscisse);
		const centreNoeud = gaucheNoeud + layoutNoeud.largeurNoeud / 2;
		const largeurEmpreinte = this.obtenirLargeurEmpreinteNoeudV2(
			noeud,
			config,
			bornesStrictes,
		);
		return {
			minX: centreNoeud - largeurEmpreinte / 2,
			maxX: centreNoeud + largeurEmpreinte / 2,
		};
	}

	calculerBornesSousArbreV2(noeud, config, bornesStrictes = false) {
		if (!noeud) return { minX: Infinity, maxX: -Infinity };
		const bornesNoeud = this.calculerBornesNoeudV2(
			noeud,
			config,
			bornesStrictes,
		);

		let minX = bornesNoeud.minX;
		let maxX = bornesNoeud.maxX;

		if (Array.isArray(noeud?.enfants)) {
			for (const enfant of noeud.enfants) {
				const bornesEnfant = this.calculerBornesSousArbreV2(
					enfant,
					config,
					bornesStrictes,
				);
				minX = Math.min(minX, bornesEnfant.minX);
				maxX = Math.max(maxX, bornesEnfant.maxX);
			}
		}

		if (Array.isArray(noeud?.conditions)) {
			for (const condition of noeud.conditions) {
				if (Array.isArray(condition?.enfants)) {
					for (const enfant of condition.enfants) {
						const bornesEnfant = this.calculerBornesSousArbreV2(
							enfant,
							config,
							bornesStrictes,
						);
						minX = Math.min(minX, bornesEnfant.minX);
						maxX = Math.max(maxX, bornesEnfant.maxX);
					}
				}
				const centreCondition = condition?.__centreBrancheV2;
				if (isFinite(centreCondition)) {
					const largeurEntete = this.obtenirLargeurEnteteConditionV2(
						condition,
						config,
					);
					minX = Math.min(minX, centreCondition - largeurEntete / 2);
					maxX = Math.max(maxX, centreCondition + largeurEntete / 2);
				}
			}
		}

		return { minX, maxX };
	}

	calculerBornesForetV2(foret, config, bornesStrictes = false) {
		if (!Array.isArray(foret) || foret.length === 0) {
			return { minX: Infinity, maxX: -Infinity };
		}
		let minX = Infinity;
		let maxX = -Infinity;
		for (const noeud of foret) {
			const bornes = this.calculerBornesSousArbreV2(
				noeud,
				config,
				bornesStrictes,
			);
			minX = Math.min(minX, bornes.minX);
			maxX = Math.max(maxX, bornes.maxX);
		}
		return { minX, maxX };
	}

	decalerSousArbreMiseEnPageV2(noeud, decalageX) {
		if (!noeud || !isFinite(decalageX) || Math.abs(decalageX) &lt; 0.0001) return;
		noeud.abscisse = `${parseFloat(noeud.abscisse) + decalageX}vw`;

		if (Array.isArray(noeud.enfants)) {
			for (const enfant of noeud.enfants) {
				this.decalerSousArbreMiseEnPageV2(enfant, decalageX);
			}
		}
		if (Array.isArray(noeud.conditions)) {
			for (const condition of noeud.conditions) {
				if (isFinite(condition?.__centreBrancheV2)) {
					condition.__centreBrancheV2 += decalageX;
				}
				if (Array.isArray(condition?.enfants)) {
					for (const enfant of condition.enfants) {
						this.decalerSousArbreMiseEnPageV2(enfant, decalageX);
					}
				}
			}
		}
	}

	decalerForetMiseEnPageV2(foret, decalageX) {
		if (!Array.isArray(foret) || !isFinite(decalageX) || Math.abs(decalageX) &lt; 0.0001) {
			return;
		}
		for (const noeud of foret) {
			this.decalerSousArbreMiseEnPageV2(noeud, decalageX);
		}
	}

	decalerConditionV2(condition, decalageX) {
		if (!condition || !isFinite(decalageX) || Math.abs(decalageX) &lt; 0.0001) return;
		if (isFinite(condition?.__centreBrancheV2)) {
			condition.__centreBrancheV2 += decalageX;
		}
		if (Array.isArray(condition?.enfants)) {
			for (const enfant of condition.enfants) {
				this.decalerSousArbreMiseEnPageV2(enfant, decalageX);
			}
		}
	}

	obtenirCentreNoeudV2(noeud, config) {
		const layoutNoeud = this.calculerMiseEnPageNoeudV2(noeud, config);
		return parseFloat(noeud.abscisse) + layoutNoeud.largeurNoeud / 2;
	}

	alignerEnfantUniqueV2(parent, enfant, config, centreCible = null) {
		if (!parent || !enfant) return;
		const centreParent =
			centreCible ?? this.obtenirCentreNoeudV2(parent, config);
		const centreEnfant = this.obtenirCentreNoeudV2(enfant, config);
		this.decalerSousArbreMiseEnPageV2(enfant, centreParent - centreEnfant);
	}

	compacterFratrieV2(noeudsFreres, config, ecartMinimal) {
		if (!Array.isArray(noeudsFreres) || noeudsFreres.length &lt; 2) return;
		const ecart = ecartMinimal ?? config.ecartHorizontalCompact;
		for (let i = 1; i &lt; noeudsFreres.length; i++) {
			const bornesPrecedentes = this.calculerBornesSousArbreV2(
				noeudsFreres[i - 1],
				config,
			);
			const bornesCourantes = this.calculerBornesSousArbreV2(
				noeudsFreres[i],
				config,
			);
			const decalage = bornesPrecedentes.maxX + ecart - bornesCourantes.minX;
			this.decalerSousArbreMiseEnPageV2(noeudsFreres[i], decalage);
		}
	}

	appliquerAntiChevauchementConditionSortieFratrieV2(noeudsFreres, config) {
		if (!Array.isArray(noeudsFreres) || noeudsFreres.length &lt; 2) return;
		for (let i = 1; i &lt; noeudsFreres.length; i++) {
			const precedent = noeudsFreres[i - 1];
			const courant = noeudsFreres[i];
			const paireAvecConditionSortie =
				precedent?.typeElement === "ConditionSortie" ||
				courant?.typeElement === "ConditionSortie";
			if (!paireAvecConditionSortie) continue;

			const bornesPrecedentes = this.calculerBornesNoeudV2(
				precedent,
				config,
				true,
			);
			const bornesCourantes = this.calculerBornesNoeudV2(
				courant,
				config,
				true,
			);
			const correction =
				bornesPrecedentes.maxX +
				config.ecartSecuriteConditionSortie -
				bornesCourantes.minX;
			if (correction > 0) {
				this.decalerSousArbreMiseEnPageV2(courant, correction);
			}
		}
	}

	appliquerAntiChevauchementConditionSortieNoeudV2(noeud, config) {
		if (!noeud) return;

		const enfants = Array.isArray(noeud?.enfants) ? noeud.enfants : [];
		this.appliquerAntiChevauchementConditionSortieFratrieV2(enfants, config);
		for (const enfant of enfants) {
			this.appliquerAntiChevauchementConditionSortieNoeudV2(enfant, config);
		}

		if (Array.isArray(noeud?.conditions)) {
			for (const condition of noeud.conditions) {
				const enfantsCondition = Array.isArray(condition?.enfants)
					? condition.enfants
					: [];
				this.appliquerAntiChevauchementConditionSortieFratrieV2(
					enfantsCondition,
					config,
				);
				for (const enfant of enfantsCondition) {
					this.appliquerAntiChevauchementConditionSortieNoeudV2(
						enfant,
						config,
					);
				}
			}
		}
	}

	appliquerAntiChevauchementConditionSortieV2(racines, config) {
		if (!Array.isArray(racines) || racines.length === 0) return;
		this.appliquerAntiChevauchementConditionSortieFratrieV2(racines, config);
		for (const racine of racines) {
			this.appliquerAntiChevauchementConditionSortieNoeudV2(racine, config);
		}
	}

	obtenirBornesConditionV2(condition, config, bornesStrictes = false) {
		const enfants = Array.isArray(condition?.enfants) ? condition.enfants : [];
		if (enfants.length > 0) {
			return this.calculerBornesForetV2(enfants, config, bornesStrictes);
		}
		const centreCondition = condition?.__centreBrancheV2;
		if (isFinite(centreCondition)) {
			const largeurEntete = this.obtenirLargeurEnteteConditionV2(
				condition,
				config,
			);
			return {
				minX: centreCondition - largeurEntete / 2,
				maxX: centreCondition + largeurEntete / 2,
			};
		}
		return { minX: Infinity, maxX: -Infinity };
	}

	compacterConditionsV2(noeud, config) {
		const conditions = Array.isArray(noeud?.conditions) ? noeud.conditions : [];
		if (conditions.length === 0) return;

		for (const condition of conditions) {
			const enfants = Array.isArray(condition?.enfants) ? condition.enfants : [];
			if (enfants.length > 1) {
				this.compacterFratrieV2(enfants, config, config.ecartHorizontalCompact);
			} else if (enfants.length === 1 &amp;&amp; isFinite(condition.__centreBrancheV2)) {
				this.alignerEnfantUniqueV2(
					noeud,
					enfants[0],
					config,
					condition.__centreBrancheV2,
				);
			}
		}

		for (let i = 1; i &lt; conditions.length; i++) {
			const bornesPrecedentes = this.obtenirBornesConditionV2(
				conditions[i - 1],
				config,
			);
			const bornesCourantes = this.obtenirBornesConditionV2(
				conditions[i],
				config,
			);
			const decalage =
				bornesPrecedentes.maxX +
				config.ecartHorizontalConditionsCompact -
				bornesCourantes.minX;
			this.decalerConditionV2(conditions[i], decalage);
		}
	}

	recentrerEnfantsSousParentV2(noeud, config) {
		const enfants = Array.isArray(noeud?.enfants) ? noeud.enfants : [];
		if (enfants.length === 0) return;
		const bornesEnfants = this.calculerBornesForetV2(enfants, config);
		if (!isFinite(bornesEnfants.minX) || !isFinite(bornesEnfants.maxX)) return;
		const centreParent = this.obtenirCentreNoeudV2(noeud, config);
		const centreEnfants = (bornesEnfants.minX + bornesEnfants.maxX) / 2;
		this.decalerForetMiseEnPageV2(enfants, centreParent - centreEnfants);
	}

	recentrerConditionsSousParentV2(noeud, config) {
		const conditions = Array.isArray(noeud?.conditions) ? noeud.conditions : [];
		if (conditions.length === 0) return;
		let minX = Infinity;
		let maxX = -Infinity;
		for (const condition of conditions) {
			const bornesCondition = this.obtenirBornesConditionV2(condition, config);
			minX = Math.min(minX, bornesCondition.minX);
			maxX = Math.max(maxX, bornesCondition.maxX);
		}
		if (!isFinite(minX) || !isFinite(maxX)) return;
		const centreParent = this.obtenirCentreNoeudV2(noeud, config);
		const centreConditions = (minX + maxX) / 2;
		const decalage = centreParent - centreConditions;
		for (const condition of conditions) {
			this.decalerConditionV2(condition, decalage);
		}
	}

	compacterNoeudV2(noeud, config) {
		if (!noeud) return;
		if (Array.isArray(noeud.enfants)) {
			for (const enfant of noeud.enfants) {
				this.compacterNoeudV2(enfant, config);
			}
		}
		if (Array.isArray(noeud.conditions)) {
			for (const condition of noeud.conditions) {
				if (Array.isArray(condition?.enfants)) {
					for (const enfant of condition.enfants) {
						this.compacterNoeudV2(enfant, config);
					}
				}
			}
		}

		const enfants = Array.isArray(noeud.enfants) ? noeud.enfants : [];
		if (enfants.length > 1) {
			this.compacterFratrieV2(enfants, config, config.ecartHorizontalCompact);
		} else if (enfants.length === 1) {
			this.alignerEnfantUniqueV2(noeud, enfants[0], config);
		}

		if (
			noeud.typeElement === "StructureSi" ||
			noeud.typeElement === "StructureSwitch"
		) {
			this.compacterConditionsV2(noeud, config);
			this.recentrerConditionsSousParentV2(noeud, config);
		}
		this.recentrerEnfantsSousParentV2(noeud, config);
	}

	compacterDispositionV2(racines, config) {
		if (!Array.isArray(racines) || racines.length === 0) return;
		for (const racine of racines) {
			this.compacterNoeudV2(racine, config);
		}
		this.compacterFratrieV2(racines, config, config.ecartHorizontalCompact);
	}

	recentrerDispositionV2(racines, config) {
		const bornes = this.calculerBornesForetV2(racines, config);
		if (!isFinite(bornes.minX) || !isFinite(bornes.maxX)) return;
		const largeurTotale = bornes.maxX - bornes.minX;
		let gaucheCible = config.margeGauche;
		if (largeurTotale &lt; config.largeurDisponible) {
			gaucheCible += (config.largeurDisponible - largeurTotale) / 2;
		}
		const decalage = gaucheCible - bornes.minX;
		this.decalerForetMiseEnPageV2(racines, decalage);
	}

	nettoyerMetaMiseEnPageV2(foret) {
		if (!Array.isArray(foret)) return;
		for (const noeud of foret) {
			if (noeud &amp;&amp; noeud.__layoutV2) {
				delete noeud.__layoutV2;
			}
			if (Array.isArray(noeud?.enfants)) {
				this.nettoyerMetaMiseEnPageV2(noeud.enfants);
			}
			if (Array.isArray(noeud?.conditions)) {
				for (const condition of noeud.conditions) {
					if (condition &amp;&amp; condition.__largeurForetEnfantsV2 !== undefined) {
						delete condition.__largeurForetEnfantsV2;
					}
					if (condition &amp;&amp; condition.__largeurBrancheV2 !== undefined) {
						delete condition.__largeurBrancheV2;
					}
					if (condition &amp;&amp; condition.__centreBrancheV2 !== undefined) {
						delete condition.__centreBrancheV2;
					}
					if (Array.isArray(condition?.enfants)) {
						this.nettoyerMetaMiseEnPageV2(condition.enfants);
					}
				}
			}
		}
	}

	reorganiserDispositionAlgoV2(algo, options = {}) {
		const config = {
			ecartHorizontal: options.ecartHorizontal ?? 0.7,
			ecartHorizontalConditions: options.ecartHorizontalConditions ?? 0.55,
			ecartVertical: options.ecartVertical ?? 9,
			largeurMinNoeud: options.largeurMinNoeud ?? 2.2,
			hauteurMinNoeud: options.hauteurMinNoeud ?? 3,
			largeurConstanteSortie: options.largeurConstanteSortie ?? 4,
			largeurMinBrancheCondition: options.largeurMinBrancheCondition ?? 2.8,
			facteurLargeurGeneral: options.facteurLargeurGeneral ?? 0.56,
			facteurLargeurProbleme: options.facteurLargeurProbleme ?? 0.52,
			facteurLargeurEnteteCondition:
				options.facteurLargeurEnteteCondition ?? 0.5,
			margeNoeud: options.margeNoeud ?? 0.2,
			margeEnteteCondition: options.margeEnteteCondition ?? 0.2,
			margeGauche: options.margeGauche ?? 2,
			largeurDisponible: options.largeurDisponible ?? 92,
			positionHaute: options.positionHaute ?? 3,
			ecartHorizontalCompact: options.ecartHorizontalCompact ?? 0.25,
			ecartHorizontalConditionsCompact:
				options.ecartHorizontalConditionsCompact ?? 0.2,
			largeurMinEmpreinteNoeud: options.largeurMinEmpreinteNoeud ?? 1.6,
			facteurEmpreinteGeneral: options.facteurEmpreinteGeneral ?? 0.7,
			facteurEmpreinteProbleme: options.facteurEmpreinteProbleme ?? 0.7,
			facteurEmpreinteProblemePartiel:
				options.facteurEmpreinteProblemePartiel ?? 0.58,
			facteurEmpreinteProblemeSansDR:
				options.facteurEmpreinteProblemeSansDR ?? 0.5,
			largeurEmpreinteSortieConstante:
				options.largeurEmpreinteSortieConstante ?? 4,
			ecartSecuriteConditionSortie:
				options.ecartSecuriteConditionSortie ?? 0.08,
		};

		const racines = Array.isArray(algo)
			? algo.filter(
					(noeud) => noeud &amp;&amp; noeud.typeElement !== "DictionnaireDonnee",
				)
			: [];
		if (racines.length === 0) return;

		const largeurForet = this.calculerMiseEnPageForetV2(racines, config);
		let gauche = config.margeGauche;
		if (largeurForet &lt; config.largeurDisponible) {
			gauche += (config.largeurDisponible - largeurForet) / 2;
		}

		this.appliquerMiseEnPageForetV2(
			racines,
			gauche,
			config.positionHaute,
			config,
		);
		this.compacterDispositionV2(racines, config);
		this.appliquerAntiChevauchementConditionSortieV2(racines, config);
		this.recentrerDispositionV2(racines, config);
		this.nettoyerMetaMiseEnPageV2(racines);
	}

	obtenirLargeurNoeudMiseEnPage(noeud, config) {
		const largeurReference = this.obtenirLargeurReferenceNoeudMiseEnPage(
			noeud.typeElement,
		);
		if (noeud.typeElement === "ConditionSortie") {
			if (
				config.utiliserDimensionsReelles &amp;&amp;
				noeud?.__elementReference instanceof ElementGraphique
			) {
				const largeurReelleSortie = this.obtenirLargeurElementEnVw(
					noeud.__elementReference,
				);
				if (largeurReelleSortie > 0) {
					return Math.max(
						config.largeurNoeudMinSortie,
						largeurReelleSortie * config.facteurLargeurReelleSortie +
							config.margeSortie,
					);
				}
			}
			return Math.max(
				config.largeurNoeudMinSortie,
				largeurReference * config.facteurLargeurNoeud,
			);
		}

		if (
			config.utiliserDimensionsReelles &amp;&amp;
			noeud?.__elementReference instanceof ElementGraphique
		) {
			const largeurReelle = this.obtenirLargeurElementEnVw(
				noeud.__elementReference,
			);
			if (largeurReelle > 0) {
				const largeurCalculee = Math.max(
					config.largeurNoeudMin,
					largeurReelle * config.facteurLargeurReelleNoeud +
						config.margeNoeud,
				);
				return this.problemeSansEntreesSorties(noeud)
					? Math.max(config.largeurNoeudMin, largeurCalculee * 0.5)
					: largeurCalculee;
			}
		}

		const largeurFallback = Math.max(
			config.largeurNoeudMin,
			largeurReference * config.facteurLargeurNoeud,
		);
		return this.problemeSansEntreesSorties(noeud)
			? Math.max(config.largeurNoeudMin, largeurFallback * 0.5)
			: largeurFallback;
	}

	texteProblemeEstVide(texte) {
		return this.nettoyerTexteImporte(
			String(texte ?? "")
				.replace(/&amp;nbsp;/g, " ")
				.replace(/\u00A0/g, " "),
		) === "";
	}

	listeProblemeEstVide(liste) {
		if (!Array.isArray(liste)) {
			return this.texteProblemeEstVide(liste);
		}
		return liste.every((entree) => this.texteProblemeEstVide(entree));
	}

	problemeSansEntreesSorties(noeud) {
		if (
			noeud?.typeElement !== "Probleme" &amp;&amp;
			noeud?.typeElement !== "Procedure"
		) {
			return false;
		}

		const elementRef = noeud?.__elementReference;
		if (elementRef instanceof Probleme) {
			return (
				this.texteProblemeEstVide(elementRef.getDonnee?.()) &amp;&amp;
				this.texteProblemeEstVide(elementRef.getResultat?.())
			);
		}

		return (
			this.listeProblemeEstVide(noeud?.listeDonnes) &amp;&amp;
			this.listeProblemeEstVide(noeud?.listeResultats)
		);
	}

	calculerMiseEnPageForet(foret, config) {
		if (!Array.isArray(foret) || foret.length === 0) {
			return { largeurForet: 0 };
		}

		let largeurForet = 0;
		for (let i = 0; i &lt; foret.length; i++) {
			const infosNoeud = this.calculerMiseEnPageNoeud(foret[i], config);
			largeurForet += infosNoeud.largeurSousArbre;
			if (i &lt; foret.length - 1) {
				largeurForet += config.ecartHorizontal;
			}
		}

		return { largeurForet };
	}

	calculerMiseEnPageNoeud(noeud, config) {
		const largeurNoeud = this.obtenirLargeurNoeudMiseEnPage(noeud, config);

		if (
			noeud.typeElement === "StructureSi" ||
			noeud.typeElement === "StructureSwitch"
		) {
			let largeurConditions = 0;
			const conditions = Array.isArray(noeud.conditions)
				? noeud.conditions
				: [];

			for (let i = 0; i &lt; conditions.length; i++) {
				const condition = conditions[i];
				const miseEnPageEnfantsCondition = this.calculerMiseEnPageForet(
					condition.enfants,
					config,
				);
				let largeurMinBranche = config.largeurMinBrancheCondition;
				if (noeud.__elementReference instanceof StructureAlternative) {
					const conditionElement =
						noeud.__elementReference._listeConditions?.children?.[i];
					const largeurCondition =
						this.obtenirLargeurElementEnVw(conditionElement);
					if (largeurCondition > 0) {
						largeurMinBranche = Math.max(
							largeurMinBranche,
							largeurCondition * config.facteurLargeurReelleCondition +
								config.margeNoeud,
						);
					}
				}
				condition.__layout = {
					largeurBranche: Math.max(
						largeurMinBranche,
						miseEnPageEnfantsCondition.largeurForet,
					),
					miseEnPageEnfantsCondition,
				};
				largeurConditions += condition.__layout.largeurBranche;
				if (i &lt; conditions.length - 1) {
					largeurConditions += config.ecartHorizontalConditions;
				}
			}

			const largeurSousArbre = Math.max(largeurNoeud, largeurConditions);
			noeud.__layout = {
				type: "conditions",
				largeurNoeud,
				largeurSousArbre,
				largeurConditions,
			};
			return noeud.__layout;
		}

		const miseEnPageEnfants = this.calculerMiseEnPageForet(
			noeud.enfants,
			config,
		);
		const largeurSousArbre = Math.max(
			largeurNoeud,
			miseEnPageEnfants.largeurForet,
		);
		noeud.__layout = {
			type: "enfants",
			largeurNoeud,
			largeurSousArbre,
			miseEnPageEnfants,
		};
		return noeud.__layout;
	}

	obtenirLargeurVisibleNoeudMiseEnPage(noeud, infosNoeud) {
		if (noeud?.__elementReference instanceof ElementGraphique) {
			const largeurReelle = this.obtenirLargeurElementEnVw(
				noeud.__elementReference,
			);
			if (largeurReelle > 0) return largeurReelle;
		}
		return infosNoeud?.largeurNoeud ?? 0;
	}

	decalerSousArbreMiseEnPage(noeud, decalageX) {
		if (!noeud || !isFinite(decalageX) || decalageX === 0) return;
		noeud.abscisse = `${parseFloat(noeud.abscisse) + decalageX}vw`;

		if (Array.isArray(noeud.enfants)) {
			for (const enfant of noeud.enfants) {
				this.decalerSousArbreMiseEnPage(enfant, decalageX);
			}
		}
		if (Array.isArray(noeud.conditions)) {
			for (const condition of noeud.conditions) {
				if (Array.isArray(condition?.enfants)) {
					for (const enfant of condition.enfants) {
						this.decalerSousArbreMiseEnPage(enfant, decalageX);
					}
				}
			}
		}
	}

	obtenirLargeurVisibleNoeudDepuisModele(noeud) {
		return this.obtenirLargeurVisibleNoeudMiseEnPage(noeud, noeud?.__layout);
	}

	obtenirCentreVisibleNoeudDepuisModele(noeud) {
		return (
			parseFloat(noeud.abscisse) +
			this.obtenirLargeurVisibleNoeudDepuisModele(noeud) / 2
		);
	}

	calculerBornesSousArbreMiseEnPage(noeud) {
		const largeurNoeud = this.obtenirLargeurVisibleNoeudDepuisModele(noeud);
		let minX = parseFloat(noeud.abscisse);
		let maxX = minX + largeurNoeud;

		if (Array.isArray(noeud?.enfants)) {
			for (const enfant of noeud.enfants) {
				const bornesEnfant = this.calculerBornesSousArbreMiseEnPage(enfant);
				minX = Math.min(minX, bornesEnfant.minX);
				maxX = Math.max(maxX, bornesEnfant.maxX);
			}
		}
		if (Array.isArray(noeud?.conditions)) {
			for (const condition of noeud.conditions) {
				if (Array.isArray(condition?.enfants)) {
					for (const enfant of condition.enfants) {
						const bornesEnfant =
							this.calculerBornesSousArbreMiseEnPage(enfant);
						minX = Math.min(minX, bornesEnfant.minX);
						maxX = Math.max(maxX, bornesEnfant.maxX);
					}
				}
			}
		}

		return { minX, maxX };
	}

	alignerEnfantUniqueDepuisModele(parentNoeud, enfantUnique) {
		const centreParent = this.obtenirCentreVisibleNoeudDepuisModele(parentNoeud);
		const centreEnfant =
			this.obtenirCentreVisibleNoeudDepuisModele(enfantUnique);
		this.decalerSousArbreMiseEnPage(enfantUnique, centreParent - centreEnfant);
	}

	appliquerNonChevauchementFratrieMiseEnPage(noeudsFreres, ecartMinimal = 0.35) {
		if (!Array.isArray(noeudsFreres) || noeudsFreres.length &lt; 2) return;

		for (let i = 1; i &lt; noeudsFreres.length; i++) {
			const bornesPrecedent = this.calculerBornesSousArbreMiseEnPage(
				noeudsFreres[i - 1],
			);
			const bornesCourant = this.calculerBornesSousArbreMiseEnPage(
				noeudsFreres[i],
			);
			const minGaucheAutorisee = bornesPrecedent.maxX + ecartMinimal;
			if (bornesCourant.minX &lt; minGaucheAutorisee) {
				this.decalerSousArbreMiseEnPage(
					noeudsFreres[i],
					minGaucheAutorisee - bornesCourant.minX,
				);
			}
		}
	}

	calculerBornesForetMiseEnPage(foret, inclureDescendants = true) {
		if (!Array.isArray(foret) || foret.length === 0) {
			return { minX: Infinity, maxX: -Infinity };
		}

		let minX = Infinity;
		let maxX = -Infinity;
		for (const noeud of foret) {
			const bornesNoeud = inclureDescendants
				? this.calculerBornesSousArbreMiseEnPage(noeud)
				: {
						minX: (() => {
							const gauche = parseFloat(noeud.abscisse);
							const largeur = this.obtenirLargeurVisibleNoeudDepuisModele(
								noeud,
							);
							const centre = gauche + largeur / 2;
							const facteurEmpreinte =
								noeud?.typeElement === "ConditionSortie" ? 0.95 : 0.68;
							const largeurEmpreinte = largeur * facteurEmpreinte;
							return centre - largeurEmpreinte / 2;
						})(),
						maxX: (() => {
							const gauche = parseFloat(noeud.abscisse);
							const largeur = this.obtenirLargeurVisibleNoeudDepuisModele(
								noeud,
							);
							const centre = gauche + largeur / 2;
							const facteurEmpreinte =
								noeud?.typeElement === "ConditionSortie" ? 0.95 : 0.68;
							const largeurEmpreinte = largeur * facteurEmpreinte;
							return centre + largeurEmpreinte / 2;
						})(),
					};
			minX = Math.min(minX, bornesNoeud.minX);
			maxX = Math.max(maxX, bornesNoeud.maxX);
		}
		return { minX, maxX };
	}

	decalerForetMiseEnPage(foret, decalageX) {
		if (!Array.isArray(foret) || !isFinite(decalageX) || decalageX === 0) return;
		for (const noeud of foret) {
			this.decalerSousArbreMiseEnPage(noeud, decalageX);
		}
	}

	appliquerNonChevauchementForetsMiseEnPage(
		forets,
		ecartMinimal = 0.35,
		inclureDescendants = true,
	) {
		if (!Array.isArray(forets) || forets.length &lt; 2) return;

		let maxXDerniereForet = -Infinity;
		for (let i = 0; i &lt; forets.length; i++) {
			const foretCourante = forets[i];
			const bornesCourantes = this.calculerBornesForetMiseEnPage(
				foretCourante,
				inclureDescendants,
			);
			if (!isFinite(bornesCourantes.minX) || !isFinite(bornesCourantes.maxX)) {
				continue;
			}

			if (isFinite(maxXDerniereForet)) {
				const minGaucheAutorisee = maxXDerniereForet + ecartMinimal;
				if (bornesCourantes.minX &lt; minGaucheAutorisee) {
					this.decalerForetMiseEnPage(
						foretCourante,
						minGaucheAutorisee - bornesCourantes.minX,
					);
				}
			}

			const bornesApresDecalage = this.calculerBornesForetMiseEnPage(
				foretCourante,
				inclureDescendants,
			);
			if (isFinite(bornesApresDecalage.maxX)) {
				maxXDerniereForet = bornesApresDecalage.maxX;
			}
		}
	}

	foretContientConditionSortie(noeuds) {
		if (!Array.isArray(noeuds)) return false;
		return noeuds.some((noeud) => noeud?.typeElement === "ConditionSortie");
	}

	postAjusterDispositionAvecDimensionsReelles(foret, options = {}) {
		const ecartMinimal = options.ecartMinimal ?? 0.03;
		const appliquerAntiChevauchementGlobal =
			options.appliquerAntiChevauchementGlobal ?? false;

		const ajusterNoeudRec = (noeud) => {
			if (Array.isArray(noeud?.enfants) &amp;&amp; noeud.enfants.length > 0) {
				for (const enfant of noeud.enfants) {
					ajusterNoeudRec(enfant);
				}
					if (noeud.enfants.length === 1) {
						this.alignerEnfantUniqueDepuisModele(noeud, noeud.enfants[0]);
					} else if (
						appliquerAntiChevauchementGlobal ||
						this.foretContientConditionSortie(noeud.enfants)
					) {
						this.appliquerNonChevauchementFratrieMiseEnPage(
							noeud.enfants,
							ecartMinimal,
						);
				}
			}

			if (Array.isArray(noeud?.conditions)) {
				const foretsDesConditions = [];
				for (const condition of noeud.conditions) {
					const enfantsCondition = Array.isArray(condition?.enfants)
						? condition.enfants
						: [];
					foretsDesConditions.push(enfantsCondition);
					for (const enfant of enfantsCondition) {
						ajusterNoeudRec(enfant);
					}
					if (enfantsCondition.length > 1) {
						this.appliquerNonChevauchementFratrieMiseEnPage(
							enfantsCondition,
							ecartMinimal,
						);
					}
				}
					this.appliquerNonChevauchementForetsMiseEnPage(
						foretsDesConditions,
						ecartMinimal,
						false,
					);
			}
		};

		for (const noeud of foret) {
			ajusterNoeudRec(noeud);
		}
		if (
			appliquerAntiChevauchementGlobal ||
			this.foretContientConditionSortie(foret)
		) {
			this.appliquerNonChevauchementFratrieMiseEnPage(foret, ecartMinimal);
		}
	}

	appliquerMiseEnPageForet(foret, gauche, haut, config) {
		if (!Array.isArray(foret) || foret.length === 0) return;
		let curseur = gauche;
		for (let i = 0; i &lt; foret.length; i++) {
			const noeud = foret[i];
			const infosNoeud =
				noeud.__layout || this.calculerMiseEnPageNoeud(noeud, config);
			this.appliquerMiseEnPageNoeud(noeud, curseur, haut, config);
			curseur += infosNoeud.largeurSousArbre + config.ecartHorizontal;
		}
	}

	appliquerMiseEnPageNoeud(noeud, gauche, haut, config) {
		const infosNoeud =
			noeud.__layout || this.calculerMiseEnPageNoeud(noeud, config);
		const positionX =
			gauche + (infosNoeud.largeurSousArbre - infosNoeud.largeurNoeud) / 2;

		noeud.abscisse = `${positionX}vw`;
		noeud.ordonnee = `${haut}vw`;

		if (infosNoeud.type === "enfants") {
			const largeurEnfants = infosNoeud.miseEnPageEnfants.largeurForet;
			if (largeurEnfants > 0) {
				const enfants = Array.isArray(noeud.enfants) ? noeud.enfants : [];
				if (enfants.length === 1) {
					const enfantUnique = enfants[0];
						const infosEnfantUnique =
							enfantUnique.__layout ||
							this.calculerMiseEnPageNoeud(enfantUnique, config);
						const centreParent =
							parseFloat(noeud.abscisse) +
							this.obtenirLargeurVisibleNoeudMiseEnPage(
								noeud,
								infosNoeud,
							) /
								2;
					const gaucheEnfantUniqueInitial =
						positionX -
						(infosEnfantUnique.largeurSousArbre -
							infosEnfantUnique.largeurNoeud) /
							2;
					this.appliquerMiseEnPageNoeud(
						enfantUnique,
						gaucheEnfantUniqueInitial,
						haut + config.ecartVertical,
						config,
					);

					const centreEnfantUnique =
						parseFloat(enfantUnique.abscisse) +
						this.obtenirLargeurVisibleNoeudMiseEnPage(
							enfantUnique,
							infosEnfantUnique,
						) /
							2;
					const decalageAlignement = centreParent - centreEnfantUnique;
					this.decalerSousArbreMiseEnPage(
						enfantUnique,
						decalageAlignement,
					);
					return;
				}

				const gaucheEnfants =
					gauche + (infosNoeud.largeurSousArbre - largeurEnfants) / 2;
				this.appliquerMiseEnPageForet(
					noeud.enfants,
					gaucheEnfants,
					haut + config.ecartVertical,
					config,
				);
			}
			return;
		}

		if (infosNoeud.type === "conditions") {
			if (infosNoeud.largeurConditions &lt;= 0) return;
			let curseurConditions =
				gauche +
				(infosNoeud.largeurSousArbre - infosNoeud.largeurConditions) / 2;

			const conditions = Array.isArray(noeud.conditions)
				? noeud.conditions
				: [];
			for (const condition of conditions) {
				const infosCondition = condition.__layout;
				if (
					infosCondition &amp;&amp;
					infosCondition.miseEnPageEnfantsCondition.largeurForet > 0
				) {
					const enfantsCondition = Array.isArray(condition.enfants)
						? condition.enfants
						: [];
					if (enfantsCondition.length === 1) {
						const enfantUniqueCondition = enfantsCondition[0];
						const infosEnfantUniqueCondition =
							enfantUniqueCondition.__layout ||
							this.calculerMiseEnPageNoeud(
								enfantUniqueCondition,
								config,
							);
						const centreBranche =
							curseurConditions + infosCondition.largeurBranche / 2;
						const gaucheEnfantUniqueConditionInitial =
							curseurConditions +
							(infosCondition.largeurBranche -
								infosEnfantUniqueCondition.largeurSousArbre) /
								2;
						this.appliquerMiseEnPageNoeud(
							enfantUniqueCondition,
							gaucheEnfantUniqueConditionInitial,
							haut + config.ecartVertical,
							config,
						);
						const centreEnfantUniqueCondition =
							parseFloat(enfantUniqueCondition.abscisse) +
							this.obtenirLargeurVisibleNoeudMiseEnPage(
								enfantUniqueCondition,
								infosEnfantUniqueCondition,
							) /
								2;
						const decalageAlignementCondition =
							centreBranche - centreEnfantUniqueCondition;
						this.decalerSousArbreMiseEnPage(
							enfantUniqueCondition,
							decalageAlignementCondition,
						);
					} else {
						const gaucheCondition =
							curseurConditions +
							(infosCondition.largeurBranche -
								infosCondition.miseEnPageEnfantsCondition.largeurForet) /
								2;
						this.appliquerMiseEnPageForet(
							condition.enfants,
							gaucheCondition,
							haut + config.ecartVertical,
							config,
						);
					}
				}
				curseurConditions +=
					infosCondition.largeurBranche + config.ecartHorizontalConditions;
			}
		}
	}

	nettoyerMetaMiseEnPage(foret) {
		if (!Array.isArray(foret)) return;
		for (const noeud of foret) {
			if (noeud &amp;&amp; noeud.__layout) {
				delete noeud.__layout;
			}
			if (Array.isArray(noeud?.enfants)) {
				this.nettoyerMetaMiseEnPage(noeud.enfants);
			}
			if (Array.isArray(noeud?.conditions)) {
				for (const condition of noeud.conditions) {
					if (condition &amp;&amp; condition.__layout) {
						delete condition.__layout;
					}
					if (Array.isArray(condition?.enfants)) {
						this.nettoyerMetaMiseEnPage(condition.enfants);
					}
				}
			}
		}
	}

	reorganiserDispositionAlgo(algo, options = {}) {
		const facteurEspacementHorizontal =
			options.facteurEspacementHorizontal ?? 0.16;
		const facteurEspacementVertical =
			options.facteurEspacementVertical ?? 1;
		const config = {
			ecartHorizontal:
				options.ecartHorizontal ?? 6 * facteurEspacementHorizontal,
			ecartHorizontalConditions:
				options.ecartHorizontalConditions ??
				5 * facteurEspacementHorizontal,
			ecartVertical:
				options.ecartVertical ?? Math.max(7, 9 * facteurEspacementVertical),
			largeurMinBrancheCondition:
				options.largeurMinBrancheCondition ??
				Math.max(5, 14 * facteurEspacementHorizontal),
			utiliserDimensionsReelles: options.utiliserDimensionsReelles ?? true,
			facteurLargeurReelleNoeud:
				options.facteurLargeurReelleNoeud ?? 0.46,
			facteurLargeurReelleSortie:
				options.facteurLargeurReelleSortie ?? 1,
			facteurLargeurReelleCondition:
				options.facteurLargeurReelleCondition ?? 0.55,
			margeNoeud: options.margeNoeud ?? 0.6,
			margeSortie: options.margeSortie ?? 0.9,
			largeurNoeudMin: options.largeurNoeudMin ?? 3,
			largeurNoeudMinSortie: options.largeurNoeudMinSortie ?? 5.4,
			facteurLargeurNoeud: options.facteurLargeurNoeud ?? 0.28,
			margeGauche: options.margeGauche ?? 2,
			largeurDisponible: options.largeurDisponible ?? 92,
			positionHaute: options.positionHaute ?? 3,
		};

		const racines = Array.isArray(algo)
			? algo.filter(
					(noeud) => noeud &amp;&amp; noeud.typeElement !== "DictionnaireDonnee",
				)
			: [];
		if (racines.length === 0) return;

		const infosForet = this.calculerMiseEnPageForet(racines, config);
		const largeurForet = infosForet.largeurForet;
		let gauche = config.margeGauche;
		if (largeurForet &lt; config.largeurDisponible) {
			gauche += (config.largeurDisponible - largeurForet) / 2;
		}

		this.appliquerMiseEnPageForet(
			racines,
			gauche,
			config.positionHaute,
			config,
		);
		this.nettoyerMetaMiseEnPage(racines);
	}

	preparerXmlTabulaRasa(contenuXml) {
		if (typeof contenuXml !== "string") return "";
		let contenu = contenuXml.replace(/^\uFEFF/, "").trimStart();

		// Certains exports TBR sont en XML 1.1 ; on normalise pour DOMParser navigateur.
		contenu = contenu.replace(
			/^&lt;\?xml[^>]*\?>/i,
			(xmlDeclaration) =>
				xmlDeclaration.replace(
					/version\s*=\s*["']1\.1["']/i,
					'version="1.0"',
				),
		);

		return contenu;
	}

	convertirTabulaRasaEnAlgoForge(contenuXml) {
		const parser = new DOMParser();
		const xmlNormalise = this.preparerXmlTabulaRasa(contenuXml);
		const documentXml = parser.parseFromString(xmlNormalise, "text/xml");
		if (documentXml.querySelector("parsererror")) {
			throw new Error("Le XML Tabula Rasa est invalide.");
		}

		const algorithme = documentXml.querySelector("Algorithme");
		if (!algorithme) {
			throw new Error("Le fichier Tabula Rasa ne contient pas d'algorithme.");
		}

		const elements = this.trouverEnfantDirect(algorithme, "Elements");
		const corpsAlgo = this.convertirEnfantsTbr(elements);
		this.reorganiserDispositionAlgoV2(corpsAlgo);
		corpsAlgo.push({ typeElement: "DictionnaireDonnee" });

		return {
			algo: corpsAlgo,
			nomAlgo: this.nettoyerTexteImporte(
				this.getTexteEnfantDirect(algorithme, "nom", ""),
			),
			estTabulaRasa: true,
		};
	}

	// Imports
	/**
	 * Importe des données JSON dans l'éditeur.
	 */
	importerJSON() {
		// On crée un input de type file pour que l'utilisateur puisse choisir un fichier
		var fileInput = document.createElement("input");
		fileInput.type = "file";
		fileInput.accept = ".json,.tbr,.xml";
		fileInput.style.display = "none";
		fileInput.addEventListener("change", () => {
			if (!fileInput.files || fileInput.files.length === 0) return;
			const selectedFile = fileInput.files[0];
			var reader = new FileReader();
			reader.onload = () => {
				try {
					if (selectedFile.size > 5000000) {
						alert(
							"Le fichier est trop volumineux (maximum 5 MégaOctets).",
						);
						return;
					}
					const algoInterprete = this.interpreterFichierAlgorithme(
						selectedFile.name,
						reader.result,
					);
					const estPlanVideAvantImport = !Array.from(
						this._espacePrincipal.children,
					).some((element) => element instanceof ElementGraphique);
					this._espacePrincipal.chargerDepuisJSON(algoInterprete.algo);
					if (algoInterprete.estTabulaRasa &amp;&amp; estPlanVideAvantImport) {
						requestAnimationFrame(() => {
							this.prettifyPlanActif({ enregistrerEvenement: false });
						});
					}
				} catch (error) {
					alert("Le fichier n'a pas été chargé correctement.");
					console.error(error);
				}
			};
			reader.readAsText(selectedFile);
		});
		fileInput.click();
	}

	// Exports
	/**
	 * Exporte le contenu de l'éditeur au format SVG.
	 *
	 * @param {Object} nodeToCopy - Le nœud à copier.
	 * @param {boolean} [download=true] - Indique si le fichier doit être téléchargé.
	 * @param {boolean} [isJSON=false] - Indique si le nœud est au format JSON.
	 * @returns {string} La chaîne SVG exportée.
	 */
	exporterSVG(nodeToCopy, download = true, isJSON = false) {
		if (verbose) console.log("exporterSVG() appelé");
		// On crée une balise style pour embarquer le style dans le fichier SVG
		var styleElement = document.createElement("style");
		var cssStyles = `
        selection-editeur {
            display: none
        }
        
        selection-simple {
            display: none
        }
        
        selection-rectangle {
            display: none;
        }
        
        plan-travail {
            width: 100vw;
            height: 100vh;
            border: 0.1vw solid #000000;
            position: relative;
            overflow: scroll;
            background-color: #FFFFFF;
            --sizeModifier: 1;
            font-family: 'Roboto', sans-serif;
            background-color: #FFFFFF;
            color: #222222;
        }
        
        probleme-element {
            display: flex;
            width: calc(var(--sizeModifier) * 30vw);
            height: fit-content;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            
            z-index: 2;
        }
        
            probleme-element > div.containerDPR {
                width: 100%;
                height: calc(var(--sizeModifier) * 4vw);
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                column-gap: calc(var(--sizeModifier) * 0.2vw);
                place-items: center;
            }
        
                probleme-element > div.containerDPR > div.donnees {
                    width: 100%;
                    height: 100%;
					display: flex;
					flex-direction: row;
					align-items: center;
					justify-content: right;
                    column-gap: calc(var(--sizeModifier) * 0.2vw);
                    place-items: center;
                    grid-column: 1;
                }
        
                    probleme-element > div.containerDPR > div.donnees > label.accolades {
                        font-size: calc(var(--sizeModifier) * 4vw);
                        transform: scaleX(0.75);
                    }
        
                    probleme-element > div.containerDPR > div.donnees > div.donneesEditable {
                        min-width: calc(var(--sizeModifier) * 1vw);
                        height: 100%;
                        grid-column: 2;
                        resize: none;
                        border: none;
                        background: none;
                        font-size: calc(var(--sizeModifier) * 0.75vw);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        word-wrap: break-word;
                        overflow: hidden;
                    }
        
                probleme-element > div.containerDPR > div.nom {
                    width: calc(var(--sizeModifier) * 10vw);
                    height: 100%;
                    grid-column: 2;
                    border: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    text-align: center;
                    font-size: calc(var(--sizeModifier) * 0.75vw);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-direction: column;
                    word-wrap: break-word;
                    overflow: hidden;
                    background-color: #FFFFFF;
                }
        
                probleme-element > div.containerDPR > div.resultat {
                    width: 100%;
                    height: 100%;
					display: flex;
					flex-direction: row;
					align-items: center;
					justify-content: left;
                    column-gap: calc(var(--sizeModifier) * 0.2vw);
                    place-items: center;
                    grid-column: 3;
                }
        
                    probleme-element > div.containerDPR > div.resultat > label.accolades {
                        font-size: calc(var(--sizeModifier) * 4vw);
                        transform: scaleX(0.75);
                    }
        
                    probleme-element > div.containerDPR > div.resultat > div.resultatEditable {
                        min-width: calc(var(--sizeModifier) * 1vw);
                        height: 100%;
                        grid-column: 2;
                        resize: none;
                        border: none;
                        background: none;
                        font-size: calc(var(--sizeModifier) * 0.75vw);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        word-wrap: break-word;
                        overflow: hidden;
                    }
        
        procedure-element {
            display: flex;
            width: calc(var(--sizeModifier) * 30vw);
            height: fit-content;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            
            z-index: 2;
        }
            
            procedure-element > div.containerDPR {
                width: 100%;
                height: calc(var(--sizeModifier) * 4vw);
                display: grid;
                grid-template-columns: 1fr 1fr 1fr;
                column-gap: calc(var(--sizeModifier) * 0.2vw);
                place-items: center;
            }
        
                procedure-element > div.containerDPR > div.donnees {
                    width: 100%;
                    height: 100%;
                    display: flex;
					flex-direction: row;
					align-items: center;
					justify-content: right;
                    column-gap: calc(var(--sizeModifier) * 0.2vw);
                    place-items: center;
                    grid-column: 1;
                }
        
                    procedure-element > div.containerDPR > div.donnees > label.accolades {
                        font-size: calc(var(--sizeModifier) * 4vw);
                        transform: scaleX(0.75);
                    }
        
                    procedure-element > div.containerDPR > div.donnees > div.donneesEditable {
                        min-width: calc(var(--sizeModifier) * 1vw);
                        height: 100%;
                        grid-column: 2;
                        resize: none;
                        border: none;
                        background: none;
                        font-size: calc(var(--sizeModifier) * 0.75vw);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        word-wrap: break-word;
                        overflow: hidden;
                    }
        
                procedure-element > div.containerDPR > div.nom {
                    width: calc(var(--sizeModifier) * 8vw);
                    height: 100%;
                    grid-column: 2;
                    border: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    text-align: center;
                    font-size: calc(var(--sizeModifier) * 0.75vw);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-direction: column;
                    word-wrap: break-word;
                    overflow: hidden;
                    background-color: #FFFFFF;
                }
        
                procedure-element > div.containerDPR > div.nom::before {
                    position: absolute;
                    content: "";
                    transform: translateX(calc(var(--sizeModifier) *-4.5vw));
                    width: calc(var(--sizeModifier) * 0.8vw);
                    height: calc(var(--sizeModifier) * 4vw);
                    border: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    border-right: none;
                    background-color: #FFFFFF;
                }
        
                procedure-element > div.containerDPR > div.nom::after {
                    position: absolute;
                    content: "";
                    transform: translateX(calc(var(--sizeModifier) *4.5vw));
                    width: calc(var(--sizeModifier) * 0.8vw);
                    height: calc(var(--sizeModifier) * 4vw);
                    border: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    border-left: none;
                    background-color: #FFFFFF;
                }
        
                procedure-element > div.containerDPR > div.resultat {
                    width: 100%;
                    height: 100%;
                    display: flex;
					flex-direction: row;
					align-items: center;
					justify-content: right;
                    column-gap: calc(var(--sizeModifier) * 0.2vw);
                    place-items: center;
                    grid-column: 3;
                }
        
                    procedure-element > div.containerDPR > div.resultat > label.accolades {
                        font-size: calc(var(--sizeModifier) * 4vw);
                        transform: scaleX(0.75);
                    }
        
                    procedure-element > div.containerDPR > div.resultat > div.resultatEditable {
                        min-width: calc(var(--sizeModifier) * 1vw);
                        height: 100%;
                        grid-column: 2;
                        resize: none;
                        border: none;
                        background: none;
                        font-size: calc(var(--sizeModifier) * 0.75vw);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        word-wrap: break-word;
                        overflow: hidden;
                    }
        
        symbole-decomposition-element {
            position: absolute;
            
            width: calc(var(--sizeModifier) * 1vw);
            height: calc(var(--sizeModifier) * 1.5vw);
            border-left: calc(var(--sizeModifier) * 0.1vw) solid #000000;
            border-right: calc(var(--sizeModifier) * 0.1vw) solid #000000;
            border-bottom: calc(var(--sizeModifier) * 0.1vw) solid #000000;
        }
        
        structure-si-element {
            display: grid;
            grid-template-columns: 0px 1fr 0px;
            grid-template-rows: 1fr;
            width: fit-content;
            height: calc(var(--sizeModifier) * 4vw);
            position: absolute;
            place-content: center;
            place-items: center;
            
            z-index: 2;
        }
        
        structure-si-element > div.triangle {
            color: #0000;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            font-size: 3vw;
            user-select: none;
            cursor: pointer;
        }
        
            structure-si-element > div.triangleGauche {
                width: calc(var(--sizeModifier) * 2.8284271247vw); /* 4 / sqrt(2), théorème de pythagore */
                height: calc(var(--sizeModifier) * 2.8284271247vw);
                border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                border-left: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                rotate: -45deg;
                grid-column: 1;
                background-color: #FFFFFF;
                transform: translate(-2%, 2%); /* Compenser l'imprecision du rotate */
            }
        
            structure-si-element > div.triangleGauche > span {
                rotate: 45deg;
                transform: translateX(-0.7vw);
            }
        
            structure-si-element > div.conditionContainer {
                display: flex;
                width: fit-content;
                height: 100%;   
                grid-column: 2;
                flex-direction: row;
            }
        
                structure-si-element > div.conditionContainer > condition-element {
                    width: calc(var(--sizeModifier) * 10vw);
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background-color: #FFFFFF;
                    border-right: calc(var(--sizeModifier) * 0.05vw) solid #000000;
                    border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    border-bottom: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                }
        
            structure-si-element > div.triangleDroit {
                width: calc(var(--sizeModifier) * 2.8284271247vw); /* 4 / sqrt(2), théorème de pythagore */
                height: calc(var(--sizeModifier) * 2.8284271247vw);
                border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                border-right: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                rotate: 45deg;
                grid-column: 3;
                background-color: #FFFFFF;
                transform: translate(2%, 2%); /* Compenser l'imprecision du rotate */
            }
        
            structure-si-element > div.triangleDroit > span {
                rotate: -45deg;
                transform: translateX(0.7vw);
            }
        
        structure-switch-element {
            display: grid;
            grid-template-columns: 0px 1fr 0px;
            grid-template-rows: 1fr 1fr;
            width: fit-content;
            height: calc(var(--sizeModifier) * 4vw);
            position: absolute;
            place-content: center;
            place-items: center;
            
            background-color: #FFFFFF;
            z-index: 2;
        }
        
            structure-switch-element > div.triangle {
                color: #0000;
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                font-size: 2vw;
                user-select: none;
                cursor: pointer;
            }
        
            structure-switch-element > div.triangleGauche {
                width: calc(var(--sizeModifier) * 2.8284271247vw); /* 4 / sqrt(2), théorème de pythagore */
                height: calc(var(--sizeModifier) * 2.8284271247vw);
                border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                border-left: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                rotate: -45deg;
                grid-column: 1;
                grid-row: 1/3;
                background-color: #FFFFFF;
                transform: translate(-2%, 2%); /* Compenser l'imprecision du rotate */
            }
        
            structure-switch-element > div.triangleGauche > span {
                rotate: 45deg;
                transform: translate(-0.7vw, 30%);
            }
        
            structure-switch-element > hr.diviseurGauche {
                width: calc(var(--sizeModifier) * 4vw);
                height: calc(var(--sizeModifier) * 0.05vw);
                grid-column: 1;
                grid-row: 1/3;
                background-color: #000000;
                z-index: 1;
                transform: translateX(-50%);
                border: 0;
            }
        
            structure-switch-element > div.expressionATester {
                width: 100%;
                height: 100%;
                grid-column: 2;
                grid-row: 1;
                resize: none;
                border: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                border-left: 0;
                border-right: 0;
                text-align: center;
                font-size: calc(var(--sizeModifier) * 0.75vw);
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                word-wrap: break-word;
                overflow: hidden;
                background-color: #FFFFFF;
                z-index: 10;
            }
        
            structure-switch-element > div.expressionATester:focus-visible {
                outline: none;
            }
        
            structure-switch-element > div.conditionContainer {
                display: flex;
                min-width: fit-content;
                width: 100%;
                height: calc(var(--sizeModifier) * 2vw);   
                grid-column: 2;
                grid-row: 2;
                flex-direction: row;
            }
        
                structure-switch-element > div.conditionContainer > condition-element {
                    min-width: calc(var(--sizeModifier) * 10vw);
                    width: 100%;
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background-color: #FFFFFF;
                    border-right: calc(var(--sizeModifier) * 0.05vw) solid #000000;
                    border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                    border-bottom: calc(var(--sizeModifier) * 0.1vw) solid #000000;
                }
        
            structure-switch-element > div.triangleDroit {
            width: calc(var(--sizeModifier) * 2.8284271247vw); /* 4 / sqrt(2), théorème de pythagore */
            height: calc(var(--sizeModifier) * 2.8284271247vw);
            border-top: calc(var(--sizeModifier) * 0.1vw) solid #000000;
            border-right: calc(var(--sizeModifier) * 0.1vw) solid #000000;
            rotate: 45deg;
            grid-column: 3;
            grid-row: 1/3;
            background-color: #FFFFFF;
            transform: translate(2%, 2%); /* Compenser l'imprecision du rotate */
            }
        
            structure-switch-element > div.triangleDroit > span {
                rotate: -45deg;
                transform: translate(0.7vw, 30%);
            }
        
            structure-switch-element > hr.diviseurDroit {
                width: calc(var(--sizeModifier) * 4vw);
                height: calc(var(--sizeModifier) * 0.05vw);
                grid-column: 3;
                grid-row: 1/3;
                background-color: #000000;
                z-index: 1;
                transform: translateX(-50%);
                border: 0;
            }
        
        condition-element {
            position: relative;
        }
        
        condition-element > div.libelle {
            width: calc(var(--sizeModifier) * 10vw);
            height: inherit;
            resize: none;
            border: none;
            background: none;
            text-align: center;
            font-size: calc(var(--sizeModifier) * 0.75vw);
            overflow: hidden;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            word-wrap: break-word;
            overflow: hidden;
            background-color: #FFFFFF;
        }
        
        condition-element > div.libelle:focus-visible {
            outline: none;
        }
        
        condition-element > button.supprimer {
            width: calc(var(--sizeModifier) * 2vw);
            height: calc(var(--sizeModifier) * 1vw);
            border: none;
            border-radius: 0 0 999em 999em;
            background-color: var(--warningColor);
            z-index: 3;
            
            font-size: calc(var(--sizeModifier) * 1vw);
            color: #FFFFFF;
            display: none;
            position: absolute;
            top: 0;
        }
        
        condition-element > div.arrowsWrapper {
            width: calc(var(--sizeModifier) * 6vw);
            height: calc(var(--sizeModifier) * 1vw);
            border: none;
            font-size: calc(var(--sizeModifier) * 1vw);
            text-align: center;
            position: absolute;
            bottom: -1.5vw;
            user-select: none;
            cursor: pointer;
            display: none;
            padding: 0 0.5vw 0.5vw 0.5vw;
        }
        
        condition-element > div.arrowsWrapper > span {
            padding: 0.5vw;
            border-radius: 0 0 999em 999em;
        }
        
        condition-element > div.ajouterAGauche {
            display: none;
        }
        
        condition-element > div.ajouterADroite {
            display: none;
        }
        
        invite-bornes-pour-si {
            display: none;
        }
        
        structure-iterative-non-bornee-element {
            display: flex;
            flex-direction: row;
            justify-content: center;
            place-items: center;
            width: fit-content;
            height: calc(var(--sizeModifier) * 4vw);
            position: absolute;
            
            z-index: 2;
        }
            structure-iterative-non-bornee-element > svg.boucleSVG {
                width: calc(var(--sizeModifier) * 4vw);
                height: calc(var(--sizeModifier) * 4vw);
            }

		structure-iterative-bornee-element {
			display: flex;
			flex-direction: row;
			justify-content: center;
			place-items: center;
			width: fit-content;
			height: calc(var(--sizeModifier) * 4vw);
			position: absolute;
			transition: all var(--transitionTime) ease;
			z-index: 2;
			gap: calc(var(--sizeModifier) * 0.5vw);
		}
        
        structure-iterative-bornee-element {
            display: flex;
            flex-direction: row;
            justify-content: center;
            place-items: center;
            width: fit-content;
            height: calc(var(--sizeModifier) * 4vw);
            position: absolute;
            
            z-index: 2;
        }

		structure-iterative-bornee-element > svg.boucleSVG {
			width: calc(var(--sizeModifier) * 4vw);
			height: calc(var(--sizeModifier) * 4vw);
		}
        
		structure-iterative-bornee-element > div.informationsBornes {
			width: calc(var(--sizeModifier) * 16vw);
			height: 100%;
			font-size: calc(var(--sizeModifier) * 1vw);
		}
        
        condition-sortie-element {
            position: absolute;
            background-image: url("assets/conditionSortie.svg");
            height: calc(var(--sizeModifier) * 4vw);
            width: calc(var(--sizeModifier) * 4vw);
            
            z-index: 2;
        }
        
        ligne-element {
            position: absolute;
            transform-origin: 0% 50%;
            margin: 0;
            padding: 0;
            border: calc(var(--sizeModifier) * 0.05vw) solid #000000;
            z-index: 0;
        }
        `;

		// On assigne le contenu de la balise style
		styleElement.textContent = cssStyles;

		let planExport = new PlanTravail();

		planExport.style.setProperty("--sizeModifier", 1);
		planExport.insertBefore(styleElement, planExport.firstChild);

		document.body.appendChild(planExport);
		if (isJSON) {
			planExport.chargerDepuisJSON(JSON.parse(nodeToCopy));
		} else {
			planExport.chargerDepuisJSON(
				nodeToCopy.exporterEnJSONSpecifier(
					Array.from(nodeToCopy.children),
				),
			);
		}
		document.body.removeChild(planExport);

		// Adapter la taille du plan pour que tout soit visible
		let tailles = planExport.getCoordMinEtMax();
		if (verbose) console.log(tailles);
		// À partir des tailles, on peut déterminer la taille de la prévisualisation, et ainsi calculer le zoom à appliquer
		let largeur = tailles.coordMax.x - tailles.coordMin.x;
		let hauteur = tailles.coordMax.y - tailles.coordMin.y;
		planExport.style.width = largeur + 5 + "vw";
		planExport.style.height = hauteur + 5 + "vw";

		// Tout déplacer pour que ce soit alligné avec le coin en haut à gauche
		planExport.toutDeplacer(
			-tailles.coordMin.x + 2.5,
			-tailles.coordMin.y + 2.5,
		);

		for (let imgBoucle of planExport.querySelectorAll("div.boucleSVG")) {
			if (verbose) console.log(imgBoucle);
			let element = imgBoucle.parentElement;
			let svgBoucle = document.createElement("svg");
			element.insertBefore(svgBoucle, imgBoucle);
			element.removeChild(imgBoucle);
			svgBoucle.outerHTML = `&lt;svg class="boucleSVG" data-name="Calque 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 425.51 386.63">
                &lt;defs>
                    &lt;style>
                        .cls-1 {
                            fill: #ffffff00;
                            stroke: #838787;
                            stroke-miterlimit: 10;
                            stroke-width: 10px;
                        }
                        .cls-2 {
                            fill: #222222;
                            stroke: #838787;
                            stroke-miterlimit: 10;
                            stroke-width: 10px;
                        }
                    &lt;/style>
                &lt;/defs>
                &lt;circle class="cls-1 " cx="193.31" cy="193.31" r="190.81"/>
                &lt;polygon class="cls-2" points="377.88 154.61 334.58 229.61 421.18 229.61 377.88 154.61"/>
            &lt;/svg>
            `;
		}

		for (let conditionSortie of planExport.querySelectorAll(
			"condition-sortie-element",
		)) {
			if (verbose) console.log(conditionSortie);
			let svgConditionSortie = document.createElement("svg");
			conditionSortie.appendChild(svgConditionSortie);
			svgConditionSortie.outerHTML = `&lt;?xml version="1.0" encoding="utf-8"?>
            &lt;!-- Generator: Adobe Illustrator 24.3.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
            &lt;svg version="1.1" id="Calque_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 320.28 319.89" style="enable-background:new 0 0 320.28 319.89;" xml:space="preserve">
            &lt;style type="text/css">
                .st0{fill:none;stroke:#838787;stroke-width:10;stroke-miterlimit:10;}
                .st1{fill:none;stroke:#838787;stroke-width:10;stroke-linecap:round;stroke-miterlimit:10;}
            &lt;/style>
            &lt;path class="st0" d="M294.62,312.59H25.4c-9.88,0-17.89-8.01-17.89-17.89V25.48c0-9.88,8.01-17.89,17.89-17.89h269.22
                c9.88,0,17.89,8.01,17.89,17.89V294.7C312.51,304.58,304.5,312.59,294.62,312.59z"/>
            &lt;line class="st1" x1="106.57" y1="204.62" x2="106.57" y2="7.62"/>
            &lt;line class="st1" x1="212.57" y1="7.62" x2="212.57" y2="204.62"/>
            &lt;path class="st1" d="M58.95,197.57"/>
            &lt;path class="st1" d="M58.95,197.57c-4.7,0-6.49,6.14-2.53,8.66l101.49,64.73c1.54,0.98,3.51,0.98,5.05,0l101.49-64.73
                c3.96-2.53,2.17-8.66-2.53-8.66"/>
            &lt;/svg>
            `;
		}

		var serializer = new XMLSerializer();
		var svgString = serializer.serializeToString(planExport);
		let templateHeader = `&lt;svg xmlns="http://www.w3.org/2000/svg">
		&lt;foreignObject x="0" y="0" width="100%" height="100%">${svgString}&lt;/foreignObject>&lt;/svg>`;

		var blob = new Blob([templateHeader], { type: "image/svg+xml" });
		var url = URL.createObjectURL(blob);
		if (download) {
			var downloadLink = document.createElement("a");
			downloadLink.href = url;
			downloadLink.download = `${
				this.querySelector("#titreAlgo").innerText
			}.svg`;
			document.body.appendChild(downloadLink);
			downloadLink.click();
			document.body.removeChild(downloadLink);
		}
		return templateHeader;
	}

	/**
	 * Exporte le contenu de l'éditeur au format JPG.
	 *
	 * @param {Object} nodeToCopy - Le nœud à copier.
	 * @param {boolean} [download=true] - Indique si le fichier doit être téléchargé.
	 * @param {boolean} [isJSON=false] - Indique si le nœud est au format JSON.
	 */
	exporterJPG(nodeToCopy, download = true, isJSON = false) {
		this.createBitmapImageFromSvg(
			"jpeg",
			nodeToCopy,
			(download = true),
			(isJSON = false),
		);
	}

	isCreatingBitmapImageFromSvg = false;

	/**
	 * Crée une image bitmap à partir d'un SVG.
	 *
	 * @param {string} mimeType - Le type MIME de l'image.
	 * @param {Object} nodeToCopy - Le nœud à copier.
	 * @param {boolean} [download=true] - Indique si le fichier doit être téléchargé.
	 * @param {boolean} [isJSON=false] - Indique si le nœud est au format JSON.
	 */
	async createBitmapImageFromSvg(
		mimeType,
		nodeToCopy,
		download = true,
		isJSON = false,
	) {
		if (this.isCreatingBitmapImageFromSvg) {
			await new Promise((resolve) => {
				setInterval(() => {
					if (!this.isCreatingBitmapImageFromSvg) resolve();
				}, 16);
			});
		}
		this.isCreatingBitmapImageFromSvg = true;
		let canvasExport = document.getElementById("canvasExport");
		canvasExport.width =
			this._planActif.getBoundingClientRect().width *
			preferences.renderScale;
		canvasExport.height =
			this._planActif.getBoundingClientRect().height *
			preferences.renderScale;
		let ctxExport = canvasExport.getContext("2d");

		let svgString = this.exporterSVG(nodeToCopy, false, isJSON);

		let testSvg = `data:image/svg+xml;base64,${btoa(
			unescape(encodeURIComponent(svgString)),
		)}`;

		let img = new Image();
		img.width = canvasExport.width;
		img.height = canvasExport.height;
		img.src = testSvg;

		const titreAlgo = this.querySelector("#titreAlgo").innerText;
		img.onload = function () {
			ctxExport.clearRect(0, 0, canvasExport.width, canvasExport.height);

			if (mimeType == "jpeg" || mimeType == "jpg") {
				ctxExport.fillStyle = "#ffffff";
				ctxExport.strokeRect = "#ffffff";
				ctxExport.fillRect(
					0,
					0,
					canvasExport.width,
					canvasExport.height,
				);
			}

			ctxExport.drawImage(
				img,
				0,
				0,
				canvasExport.width,
				canvasExport.height,
			);
			let downloadLink = document.createElement("a");
			downloadLink.href = canvasExport.toDataURL(`image/${mimeType}`, 1);
			downloadLink.download = `${titreAlgo}.${mimeType}`;

			document.body.appendChild(downloadLink);
			downloadLink.click();
			document.body.removeChild(downloadLink);
			editeur.isCreatingBitmapImageFromSvg = false;
		};
	}

	/**
	 * Exporte le contenu de l'éditeur au format PNG.
	 *
	 * @param {Object} nodeToCopy - Le nœud à copier.
	 * @param {boolean} [download=true] - Indique si le fichier doit être téléchargé.
	 * @param {boolean} [isJSON=false] - Indique si le nœud est au format JSON.
	 */
	exporterPNG(nodeToCopy, download = true, isJSON = false) {
		this.createBitmapImageFromSvg("png", nodeToCopy, download, isJSON);
	}

	adjustFontSize(el, minFontSize = 0.45, maxFontSize = 1.2) {
		// Set the font size to the maximum
		let fontSize = maxFontSize;
		el.style.fontSize = `calc(var(--sizeModifier)* ${fontSize}vw)`;

		// Check for overflow
		const isOverflowing = () =>
			el.scrollWidth > el.clientWidth ||
			el.scrollHeight > el.clientHeight;

		// Reduce font size gradually until there's no overflow or until the minimum font size is reached
		while (isOverflowing() &amp;&amp; fontSize > minFontSize) {
			fontSize -= 0.05; // decrement step
			el.style.fontSize = `calc(var(--sizeModifier)* ${fontSize}vw)`;
		}
	}
}
window.customElements.define("editeur-interface", Editeur);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnomalieConceptuelle.html">AnomalieConceptuelle</a></li><li><a href="AvertissementConceptuel.html">AvertissementConceptuel</a></li><li><a href="AvertissementDonneeDynamiquementTypee.html">AvertissementDonneeDynamiquementTypee</a></li><li><a href="AvertissementInformationsInconsistantesSi.html">AvertissementInformationsInconsistantesSi</a></li><li><a href="AvertissementPlanTropGrand.html">AvertissementPlanTropGrand</a></li><li><a href="AvertissementSProblemeJamaisExecute.html">AvertissementSProblemeJamaisExecute</a></li><li><a href="AvertissementStructureInoptimale.html">AvertissementStructureInoptimale</a></li><li><a href="AvertissementTropDeSousElements.html">AvertissementTropDeSousElements</a></li><li><a href="Bibliotheque.html">Bibliotheque</a></li><li><a href="Condition.html">Condition</a></li><li><a href="ConditionSortie.html">ConditionSortie</a></li><li><a href="Editeur.html">Editeur</a></li><li><a href="ElementGraphique.html">ElementGraphique</a></li><li><a href="ElementMenu.html">ElementMenu</a></li><li><a href="ElementMenuCompose.html">ElementMenuCompose</a></li><li><a href="ElementMenuKeyboardTip.html">ElementMenuKeyboardTip</a></li><li><a href="ElementParent.html">ElementParent</a></li><li><a href="ErreurArretHorsIteratif.html">ErreurArretHorsIteratif</a></li><li><a href="ErreurArretIteratifBornee.html">ErreurArretIteratifBornee</a></li><li><a href="ErreurBoucleBorneeSansFin.html">ErreurBoucleBorneeSansFin</a></li><li><a href="ErreurBoucleSansSortie.html">ErreurBoucleSansSortie</a></li><li><a href="ErreurComparaisonSwitch.html">ErreurComparaisonSwitch</a></li><li><a href="ErreurConceptuelle.html">ErreurConceptuelle</a></li><li><a href="ErreurDonneeInutilisee.html">ErreurDonneeInutilisee</a></li><li><a href="ErreurDonneeMagique.html">ErreurDonneeMagique</a></li><li><a href="ErreurResultatInutilisee.html">ErreurResultatInutilisee</a></li><li><a href="ErreurSyntaxeAssignation.html">ErreurSyntaxeAssignation</a></li><li><a href="ErreurSyntaxeComparaison.html">ErreurSyntaxeComparaison</a></li><li><a href="ErreurTypesInconsistantsAlternatif.html">ErreurTypesInconsistantsAlternatif</a></li><li><a href="EvenementComposite.html">EvenementComposite</a></li><li><a href="EvenementCreationElement.html">EvenementCreationElement</a></li><li><a href="EvenementDeplacementCondition.html">EvenementDeplacementCondition</a></li><li><a href="EvenementDeplacementElement.html">EvenementDeplacementElement</a></li><li><a href="EvenementDeplacementElementMultiples.html">EvenementDeplacementElementMultiples</a></li><li><a href="EvenementDispositionAutomatique.html">EvenementDispositionAutomatique</a></li><li><a href="EvenementEdition.html">EvenementEdition</a></li><li><a href="EvenementEditionDonneesProbleme.html">EvenementEditionDonneesProbleme</a></li><li><a href="EvenementEditionExpressionSwitch.html">EvenementEditionExpressionSwitch</a></li><li><a href="EvenementEditionLibelleCondition.html">EvenementEditionLibelleCondition</a></li><li><a href="EvenementEditionLibelleProbleme.html">EvenementEditionLibelleProbleme</a></li><li><a href="EvenementEditionResultatsProbleme.html">EvenementEditionResultatsProbleme</a></li><li><a href="EvenementEditionStructureIterative.html">EvenementEditionStructureIterative</a></li><li><a href="EvenementEditionTexte.html">EvenementEditionTexte</a></li><li><a href="EvenementLiaison.html">EvenementLiaison</a></li><li><a href="EvenementPlaceholder.html">EvenementPlaceholder</a></li><li><a href="EvenementSuppressionElement.html">EvenementSuppressionElement</a></li><li><a href="EvenementSuppressionLiaison.html">EvenementSuppressionLiaison</a></li><li><a href="FenetreModale.html">FenetreModale</a></li><li><a href="IndicateurZoom.html">IndicateurZoom</a></li><li><a href="Information.html">Information</a></li><li><a href="Initialise%252520l_indicateur%252520de%252520zoom%252520et%252520configure%252520les%252520boutons%252520de%252520zoom..html">Initialise l'indicateur de zoom et configure les boutons de zoom.</a></li><li><a href="Initialise%252520l_%2525C3%2525A9diteur%252520et%252520configure%252520les%252520%2525C3%2525A9v%2525C3%2525A9nements%252520et%252520les%252520%2525C3%2525A9l%2525C3%2525A9ments%252520de%252520l_interface%252520utilisateur..html">Initialise l'éditeur et configure les événements et les éléments de l'interface utilisateur.</a></li><li><a href="InviteBornesPourSI.html">InviteBornesPourSI</a></li><li><a href="InviteNouvelleBibliotheque.html">InviteNouvelleBibliotheque</a></li><li><a href="Lien.html">Lien</a></li><li><a href="LienCompositionProbleme.html">LienCompositionProbleme</a></li><li><a href="LienDroit.html">LienDroit</a></li><li><a href="LienTriple.html">LienTriple</a></li><li><a href="Ligne.html">Ligne</a></li><li><a href="MenuCompte.html">MenuCompte</a></li><li><a href="MenuContextuel.html">MenuContextuel</a></li><li><a href="MenuDeroulant.html">MenuDeroulant</a></li><li><a href="PlanTravail.html">PlanTravail</a></li><li><a href="Probleme.html">Probleme</a></li><li><a href="Procedure.html">Procedure</a></li><li><a href="RepresentationSelectionSimple.html">RepresentationSelectionSimple</a></li><li><a href="Selection.html">Selection</a></li><li><a href="SelectionRectangle.html">SelectionRectangle</a></li><li><a href="SousPlanTravail.html">SousPlanTravail</a></li><li><a href="StructureAlternative.html">StructureAlternative</a></li><li><a href="StructureIterative.html">StructureIterative</a></li><li><a href="StructureIterativeBornee.html">StructureIterativeBornee</a></li><li><a href="StructureIterativeNonBornee.html">StructureIterativeNonBornee</a></li><li><a href="StructureSi.html">StructureSi</a></li><li><a href="StructureSwitch.html">StructureSwitch</a></li><li><a href="SymboleDecomposition.html">SymboleDecomposition</a></li><li><a href="ThemeEditeur.html">ThemeEditeur</a></li><li><a href="Type.html">Type</a></li></ul><h3>Global</h3><ul><li><a href="global.html#sanitizeHTML">sanitizeHTML</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Feb 17 2026 17:04:55 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
